<html><head><title>Владимир Маслов. Введение в Perl</title></head><body><pre><div align=right><form action=/PERL/russperl5/perl.txt><select name=format><OPTION VALUE="_Contents">Содержание<OPTION VALUE="_with-big-pictures.html">Fine HTML<OPTION VALUE="_with-big-pictures.html">Printed version<OPTION VALUE="_Ascii.txt">txt(Word,КПК)<OPTION VALUE="">Lib.ru html</select><input type=submit value=go></form></div><pre>
<ul><a name=0></a><h2>Владимир Маслов. Введение в Perl</h2></ul>

---------------------------------------------------------------
   <b>&copy; Copyright (C) Маслов Владимир Викторович</b>
    Все замечания и предложения направляйте по адресу:
    <a href=mailto:maslov@klgtts.kaluga.su>maslov@klgtts.kaluga.su</a>
    <a href=mailto:maslov@news.kaluga.rosmail.com>maslov@news.kaluga.rosmail.com</a>
---------------------------------------------------------------

Все  примеры  в  книге  проверены  для Perl версии 5.003
операционной системы Unix FreeBSD 2.1.0.
===============================================================

<ul><a name=1></a><h2>Содержание</h2></ul>

<ul>
<li><a href=perl.txt#2> * Аннотация * </a>
<li><a href=perl.txt#3> * От простого к сложному * </a>
<li><a href=perl.txt#8> * Запуск интерпретатора Пел * </a>
<li><a href=perl.txt#32> * Синтаксис * </a>
<li><a href=perl.txt#42> * Переменные * </a>
<li><a href=perl.txt#49> * Встроенные переменные Пел * </a>
<li><a href=perl.txt#98> * Регулярные выражения (шаблоны) * </a>
<li><a href=perl.txt#101> * Операторы и приоритеты * </a>
<li><a href=perl.txt#133> * Встроенные функции * </a>
<li><a href=perl.txt#183> * Группа системных вызовов * </a>
<li><a href=perl.txt#302> * Подпрограммы * </a>
<li><a href=perl.txt#308> * Модули (packages) * </a>
<li><a href=perl.txt#316> * Форматы * </a>
<li><a href=perl.txt#317> * Отладка Пел программ * </a>
<li><a href=perl.txt#318> * Список литературы * </a>
<li><a href=perl.txt#319> * Интернет - ссылки * </a>
</ul>
<!--
<OL>
<li> <a href="annot.txt"> Аннотация.</a>
<li> <a href="begin.txt"> От простого к сложному.</a>
<li> <a href="run.txt"> Запуск Пел - программы </a>
<li> <a href="syntax.txt"> Синтаксис </a>
	<OL>
	<li> <a href="syntax.txt"> Декларации (объявления). </a>
	<li> <a href="syntax.txt"> Простое предложение. </a>
	<li> <a href="syntax.txt"> Сложные предложения. </a>
	<li> <a href="syntax.txt"> Циклы. </a>
		<OL>
	<li> <a href="syntax.txt">    while </a>
	<li> <a href="syntax.txt">    Операторы управления циклом. </a>
			<OL>
	<li> <a href="syntax.txt">       next </a>
	<li> <a href="syntax.txt"> 	last </a>
	<li> <a href="syntax.txt"> 	redo </a>
			</OL>
	<li> <a href="syntax.txt">     for </a>
	<li> <a href="syntax.txt">     foreach </a>
		</OL>
	<li> <a href="syntax.txt"> Блоки и оператор switch. </a>
	<li> <a href="syntax.txt"> Оператор goto. </a>
	<li> <a href="syntax.txt"> POD операторы. Документирование программ. </a>
	</OL>
<li> <a href="dat.txt"> Переменные </a>
	<OL>
	<li> Контекст.
	<li> Скалярные значения.
	<li> Конструкторы скаляров.
	<li> Конструкторы списков.
	<li> Тип typeglobs
	</OL>
<li> <a href="sysvar.txt"> Встроенные переменные </a>
<li> <a href="re.txt"> Регулярные выражения (шаблоны) </a>
<li> <a href="op.txt"> Операторы и приоритеты </a>
	<OL>
	<li> Термы и левосторонние списковые операторы.
	<li> Унарные операторы.
	<li> Операторы "привязки" =~ и != .
	<li> Мультипликативные операторы.
	<li> Аддитивные операторы.
	<li> Операторы сдвига.
	<li> Именованные унарные операторы.
	<li> Операторы отношений.
	<li> Операторы равенства.
	<li> Операторы работы с битами.
	<li> Логические операторы &amp;&amp; (AND) и || (OR).
	<li> Оператор диаппазона '..'
	<li> Условный оператор '?:'
	<li> Операторы присваивания.
	<li> Оператор ',' (запятая)
	<li> Логические not, and, or, xor
	<li> Операторы ограничители строк.
	<li> Операторы ввода-вывода.
	<li> Слияние констант.
	<li> Целочисленная арифметика.
	</OL>
<li> <a href="func.txt">  Встроенные функции </a>
<li> <a href="sub.txt"> Подпрограммы </a>
	<OL>
	<li> Private переменные.
	<li> Переменные типа local.
	<li> Прототипы (prototypes).
	<li> Ссылка как параметр.
	<li> Переопределение встроенных функций.
	<li> Автозагрузка.
	</OL>
<li> <a href="mod.txt"> Модули </a>
	<OL>
	<li> Таблицы имен.
	<li> Конструкторы и деструкторы.
	<li> Классы.
	<li> Создание библиотеки.
	<li> Pragma библиотеки.
	<li> Стандартные библиотеки.
	<li> CPAN
	</OL>
<li> <a href="form.txt"> Форматы отчетов </a>
<li> <a href="debug.txt"> Отладка </a>
<li> <a href="books.txt"> Список литературы.</a>
<li> <a href="internet.txt"> Интернет - ссылки.</a>
</OL>
Все замечания и предложения направляйте по адресу: <p>
<a href="mailto:maslov@klgtts.kaluga.su"> maslov@klgtts.kaluga.su </a><p>
<a href="mailto:maslov@news.kaluga.rosmail.com"> maslov@news.kaluga.rosmail.com </a><p>
-->

<ul><a name=2></a><h2> * Аннотация * </h2></ul>

     В  книге  приводятся  начальные  сведения  по новому языку
программирования Perl.
       Данный  язык  получил  широкое распространение в связи с
развитием компьютерной  сети  Интернет.  Все  примеры  в  книге
проверены  для  Perl  версии  5.003  операционной  системы  Unix
FreeBSD 2.1.0.

     Для    программистов,    системных    администраторов    и
пользователей компьютеров.

(C) Маслов Владимир Викторович.

<ul><a name=3></a><h2> * От простого к сложному * </h2></ul>

     Прежде  чем  приступить к последовательному ознакомлению с
не знакомым для вас языком, должен оговориться и  сказать,  что
все примеры да и сам язык описанию которого посвящена эта книга
это Perl версии 5.003 для операционной системы  FreeBSD  версии
2.01.   Существуют  реализации  этого  языка  для  операционных
систем OS/2 , MS-DOS и Windows NT но  они  немного  отстают  по
возможностям от оригинала, рожденного в недрах Юникса.

<ul><a name=4></a><h2>Пример 1 Введите в файл test1.pl следующие строки:</h2></ul>

		#!/usr/local/bin/perl
		# Содержимое файла test1.pl
		print "Наше Вам с кисточкой!\n";

А теперь подробно разберем каждую строку.

#!/usr/local/bin/perl
	Данная строка должна быть первой в любой Пел-программе.
Она указыванет системному интерпретатору что данный файл - это  Пел-программа.

# Содержимое файла test1.pl
	Эта строка называется комментарием. Она всегда начинается
символом '#' и заканчивается таким  объяснением что как говорил
великий  Ходжа Насреддин "это тонкий филосовский
вопрос", а говоря простым языком здесь можно писать все что угодно.
Даже пожелание  руководству. Уж здесь оно точно до него не
дойдет.

print "Наше Вам с кисточкой!\n";
	Самая последняя ну и конечно главная. Она просто выводит
на экран надпись "Наше Вам с кисточкой!".

Здесь слово print - это команда "вывести". Все что в кавычках - это символы,
\n - перевод строки и ';' - признак конца команды. Он обязателен.
В одной строке может быть несколько команд и все они должны завершаться
символом ';'. После него может быть символ '#' - это значит остаток
строки считается комментарием.

Над этой строкой автору
пришлось больше всего поломать голову так как в нее постоянно
лезли какие то странные "hello", "hello all", "Построемся и спасемся",
"Строй наше спасение" и т.д и т.п.

Если вы никогда не работали с Пел, то бъюсь на спор в 10$, что данная
программа сразу у вас не заработает!
Не потому что она не верна, а потому что "Нельзя объять необъятное".
Сразу, потом можно, да и то частями.
Сначало сделайте ваш файл test1.pl исполняемым. Для этого введите
команду:

	chmod +x test1.pl

Затем проверьте где у вас Пел. Для этого введите:

	which perl

Система вам выдаст что то вроде: /usr/bin/perl

Если: perl: Command not found.

То тогда закройте книжку и ложитесь спать. У вас просто нет Пел или
он не установлен. А мне остается послать вас к системному администратору
или к man (для переводчиков- man сокращение от manual а не то что вы подумали).

Теперь проверьте что бы строка 01 содержала то что выдала команда which.
Если совпало то введите:

	test1.pl

и бъсь на 50$ что и теперь программа не заработает, так как правильней
ввести:

	./test1.pl

Если я проиграл, то не радуйтесь. Да же если вам удалось запустить программу
как test1.pl это значит, что у вас будут неприятности в будущем.

<ul><a name=5></a><h2>Пример 2 Данная программа выводит на экран все ваши секреты. А именно файл /etc/passwd.</h2></ul>

	#!/usr/local/bin/perl
	open(PASS, "&lt;/etc/passwd") || die "Файл не найден!";
	while(&lt;PASS>)
	    {
	    print;
	    }
	close(PASS);

Пояснения:

open(PASS, "&lt;/etc/passwd") || die "Файл не найден!";
	"Открыть" файл т.е. создать указатель файла PASS и
в случае ошибки выдать "Файл не найден!" и закончить программу.

while(&lt;PASS>)
	Читать по одной строке файла в переменную по умолчанию $_.

  {
	Открыть блок операторов.

  print;
	Вывести на экран переменную по умолчанию $_

   }
	Конец блока.

close(PASS);
	Закрыть файл. Этого можно и не делать так-как файл автоматически
закроется после окончания программы.

Результат работы этой программы тот же что и команды cat /etc/passwd.
По экрану пробежали непонятные строки но зато теперь перед вами
открыты горизонты Пел программирования!
Все последующие примеры будут развитием этой программы и она
превратится из гадкого утенка в прекрасного лебедя (не генерала).

<ul><a name=6></a><h2>Пример 3 Разделенеие полей.</h2></ul>

      #!/usr/local/bin/perl
      open(PASS, "&lt;/etc/passwd") || die "Файл не найден!";
      while(&lt;PASS>)
          {
	    ($login, $pass, $uid, $gid, $name, $home_dir, $shell) = split(':');
	    print "$login \t $name\n";
          }
      close(PASS);

Пояснение:

($login, $pass, $uid, $gid, $name, $home_dir, $shell) = split(':');
	Присвоить указанным переменным поля входной строки, считая разделителем символ ':'.

print "$login \t $name\n";
	Вывести login - имя пользователя и его описание. Поля разделены символом '\t' - табуляции.


<ul><a name=7></a><h2>Пример 4 Вывести имена пользователей отсортированных по группам.</h2></ul>

	#!/usr/local/bin/perl
	open(PASS, "sort -n -t : +3 -4 +0 /etc/passwd|") || die "Файл не найден!";
	while(&lt;PASS>)
	    {
	    ($login, $pass, $uid, $gid, $name, $home_dir, $shell) = split(':');
	    print "$login \t $gid \t $name\n";
	    }
	close(PASS);

Поеснения:

open(PASS, "sort -n -t : +3 -4 +0 /etc/passwd|") || die "Файл не найден!";
	В данной строке весь фокус! Входным файлом для нашей программы
стал выход команды sort которая и отсортирует входные данные.


Форматированный вывод.

Ну а теперь напечатаем на экране все наши данные в удобной форме.


#!/usr/local/bin/perl

open(PASS, "sort -n -t : +3 -4 +0 /etc/passwd|") || die "Файл не найден!";
while(&lt;PASS>)
    {
    ($login, $pass, $uid, $gid, $name, $home_dir, $shell) = split(':');
    write();	# Форматированный ывод данных.
    }
close(PASS);
exit 0;		# Завершение программы

############ Описание формы вывода ##################

format STDOUT =

Пользователь: ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
				$name
              ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
                                $name
              ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
                                $name
----------------------------------------------------------------------
Login:@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;   Uid:@&lt;&lt;&lt;  Gid:@&lt;&lt;&lt;  Home dir:@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
      $login,         $uid,     $gid,          $home_dir
----------------------------------------------------------------------

.	# Это последняя строка программы


Фрагмент результата:

Пользователь: Калужский ликеро-водочный завод. Лучшие водки и
              настойки. Звонить только перед праздником Кострикову
              Анатолию т. 2-23-06,,,
----------------------------------------------------------------------
Login:uucryst     Uid:1055  Gid:66    Home dir:/var/spool/uucppublic/
----------------------------------------------------------------------


Пользователь: Торговый Дом Дилен,,,


----------------------------------------------------------------------
Login:uudilen     Uid:1075  Gid:66    Home dir:/var/spool/uucppublic
----------------------------------------------------------------------

Если вам интересно узнать как работает эта программа, то переверните
страницу и начините свое путешествие в мире Пел.
Желаю удачи!

<ul><a name=8></a><h2> * Запуск интерпретатора Пел * </h2></ul>

<ul><a name=9></a><h2>Синтаксис:</h2></ul>

	perl [ключи] файл аргументы

Перед стартом Пел ищет скрипт (программу) в следующем порядке:

	1. В командной строке если указан ключ '-e'

	2. Содержимое файла указанного в командной строке. В первой
	строке можно указывать #!/usr/bin/perl для "автоматического"
	запуска скрипта.

	3. Стандартный ввод/вывод если не указан файл или аргументы
	содержащие имя файла. Для передачи аргументов скрипту из
	стандартного потока имя файла в командной строке обозначается
	символом '-'.

В методах 1 и 2 Пел сканирует строки начиная с первой если не
указан ключ '-x', в противном случае началом программы считается
строка с символами '#!' в начале и содержащая слово 'perl'.
Концом программы считается строка '__END__'.
В строке с '#!' можно указывать и ключи. Например '#!/bin/perl -d'
для отладки программ.

После "обнаружения" скрипта Пел компилирует его целиком во внутреннее
представление. Если обнаруживаются ошибки то выполнение прекращается.
Если ошибок нет он выполняется. Если скрипт заканчивается без
команд exit() или die() то по умолчанию выполняется команда exit(0)
обозначающая нормальное завершение программы.

<ul><a name=10></a><h2>Ключи:</h2></ul>

<ul><a name=11></a><h2>-Oцифры</h2></ul>
Код символа-разделителя записей. По умолчанию \0.

<ul><a name=12></a><h2>-a</h2></ul>
Включает режим автоматического разделения (split) переменной $_
в массив $F. Применяется с ключами -n и -p.

<ul><a name=13></a><h2>-c</h2></ul>
Выполняется синтаксическая проверка скрипта и выход без запуска.

<ul><a name=14></a><h2>-d</h2></ul>
Запуск в режиме интерактивной отладки.

<ul><a name=15></a><h2>-Dчисло или Dсписок</h2></ul>
Установить флаги отладки Пел. Например -d14 проследить
как Пел исполняет вашу программу.

	1	p	Синтаксический разбор
	2	s	Состояние стека
	4	l	Состояние стека имен
	8	t	Трассировка исполнения
	16	o	Создание оператора узла
	32	c	Строковое/числовое преобразование
	64	p	Вывод команды препроцессора для -P
	128	m	Распределение памяти
	256	f	Обработка формата
	512	r	Синтаксический разбор регулярных выражений
	1024	x	Дамп синтаксического дерева
	2048	u	Проверка защиты
	4096	L	"Утечка" памяти
	8192	H	Дамп хеша
	16384	X	Распределение scratchpad
	32768	D	Очистка


<ul><a name=16></a><h2>-e команда</h2></ul>
Выполнение скрипта из одной строки указанного в командной строке.

<ul><a name=17></a><h2>-F шаблон</h2></ul>
Указывает шаблон разделения в режиме работы с ключом -a

<ul><a name=18></a><h2>-iрасширение</h2></ul>
Применяется для резервной копии файла обрабатываемого оператором '&lt;>'.
Оригинал хранится в файле с тем же именем что и исходный, но с
указанным расширением.

Пример:
	perl -p -i.old -e "s/рядовой/ефрейтор/" file

	- Поменять все слова "рядовой" на "ефрейтор" в файле file
	а оригинал записать в файле file.old

<ul><a name=19></a><h2>-Iдиректория</h2></ul>
Директория includ- файлов для С препроцессора. Применяется с ключом -P
по умолчанию это /usr/include и /usr/lib/perl.

<ul><a name=20></a><h2>-lчисло</h2></ul>
Автоматическая обработка символа конца строки. Работает в двух случаях.
1. Отбрасывает последний символ читаемых строк для режимов -n и -p
2. Присваивает указанное значение переменной $\. Таким образом
к концу каждой строки выводимой оператором print добавляется этот символ.

<ul><a name=21></a><h2>-n</h2></ul>
Зацикливает скрипт и последовательно обрабатывает файлы указанные
в командной строке. Позволяет создавать команды подобные sed или awk.
Операторы BEGIN и END дают возможность делать начальные и конечные
установки. Содержимое файлов не выводится.

<ul><a name=22></a><h2>-p</h2></ul>
То же что и -n но печатает обрабатываемые строки файлов.

<ul><a name=23></a><h2>-P</h2></ul>
Предварительная обработко препроцессором языка С. Будьте внимательны
и не применяйте в комментариях слова 'if', 'else' или 'define'
т.к. это команды С - препроцессора.

<ul><a name=24></a><h2>-s</h2></ul>
Включение режима обработки ключей командной строки запуска скрипта.
Все аргументы с символом '-' в начале, считаются ключом и переменным
с таким же именем присваивается значение true.

<ul><a name=25></a><h2>-S</h2></ul>
Использование системной переменной PATH для поиска скрипта.
Данный ключ применяется в системах не воспринимающих последовательность
"#!" в начале скрипта для указания интерпретатора.

<ul><a name=26></a><h2>-T</h2></ul>
Режим проверки "дыр" в защите. Обычно это нужно для программ
работающих в режиме повышенной привелегии (setuid, setguid).
Желательно для CGI скриптов.

<ul><a name=27></a><h2>-u</h2></ul>
Принудительный дамп памяти после компиляции скрипта. Этот дамп
можно потом использовать для создания исполняемого файла с
помощью программы undump.

<ul><a name=28></a><h2>-U</h2></ul>
Разрешение выполнять опасные операции. Например стереть директорию
или выполнять явно не закрытую программу.

<ul><a name=29></a><h2>-v</h2></ul>
Вывод номера версии Пел.

<ul><a name=30></a><h2>-w</h2></ul>
Вывод имен переменных используемых только один раз, имен скаляров
используемых до их определения, имен переопределяемых подпрограмм,
ссылок на неопределенный указатели файлов, попыток записи в файлы
открытых только на "чтение", употребление не коретных записей чисел,
использование массивов как скаляров, рекурсия более 100 уровней.

<ul><a name=31></a><h2>-x директория</h2></ul>
Режим запуска скрипта вставленного в  файл содержащий
обычный текст. Началом скрипта считаестся строка с символами '#!'
в начале и содержащия слово perl. Концом - строка с '__END__'
Указанная директория становится текущей в момент исполнения.
Если необходимо читать последующие строки то это лучше делать
через указатель файла DATA.


<ul><a name=32></a><h2> * Синтаксис * </h2></ul>

Пел программа (скрипт) состоит из последовательности деклараций и предложений.
Единственно что должно быть обязательно декларировано это форматы отчетов
и подпрограммы (функции). Все не объявленные переменные, массивы, имеют
значение 0 или null.

<ul><a name=33></a><h2>Декларации (объявления).</h2></ul>

Пел имеет свободный формат. Комментарии начинаются с символа '#' и
продолжаются до конца строки.
Декларации могут использоваться в любом месте программы так же как и
предложения (statements) но действуют они только в фазе компиляции
программы. Обычно их помещают или в начале или в конце программы.
Декларация подпрограмм позволяет использовать имя подпрограммы
как списковый оператор начиная с момента декларирования.

Пример:
	sub test;	# Декларация подпрограммы test

	$var1 = test $0; # Использование как оператора списка.

Декларации подпрограмм могут быть загружены из отдельного файла
предложением require или загружено и импортировано в текущую
область имен предложением use. Подробно см. главу Модули.


<ul><a name=34></a><h2>Простое предложение.</h2></ul>

Простое предложение обязательно
заканчивается символом ';' если только это не последнее предложение
в блоке где ';' можно опустить. Заметьте что существуют операторы
такие как eval{} и do{} которые выглядят как сложные предложения
но на самом деле это термы и требуют обязательного указания конца
предложения.

Любое простое предложение может содержать single модификатор
перед ';'. Существуют следующие single модификаторы:

	if EXPR
	unless EXPR
	while EXPR
	until EXPR

где EXPR - выражение возвращающее логическое значение true или false.
Модификаторы while и until вычисляются в начале предложения кроме блока do который выполняется первым.

if EXPR		- Модификатор "если". Предложение выполняется если EXPR возвращает true.

Пример:
	$var = 1;
	$var2 = 3 if $var > 0; # Результат: $var2 = 3

while EXPR	- Модификатор "пока". Предложение выполняется столько раз пока EXPR = true

Пример:
	$var = 1;
	print $var++ while $var &lt; 5; # Печать $var с инкрементом

Результат: 1234


until EXPR	- Модификатор "до ". Предложение выполняется  до тех пор пока EXPR = false

Пример:
	$var = 1;
	print $var++ until $var > 5; # Печать $var с инкрементом

Результат: 12345

unless EXPR	- Модификатор "если не" . Обратный к if. Выражение выполняется есле EXPR = false.

Пример:
	$var = 1;
	print $var++ unless $var > 5; # Печать $var с инкрементом

Результат: 1


<ul><a name=35></a><h2>Сложные предложения.</h2></ul>

Последовательность простых предложений ограниченная функциональными
ограничителями называется блоком. В Пел это может быть
целый файл, последовательность предложений в операторе eval{} или
чаще всего это множество простых предложений ограниченных круглыми
скобками '{}'.

Сужествуют следующие виды сложных предложений:

	if (EXPR) BLOCK
	if (EXPR) BLOCK else BLOCK
	if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK

	LABEL while (EXPR) BLOCK
	LABEL while (EXPR) BLOCK continue BLOCK
	LABEL for (EXPR; EXPR; EXPR) BLOCK
	LABEL foreach VAR (LIST) BLOCK
	LABEL BLOCK continue BLOCK

Обратите внимание, что сложные предложения описаны в термах блоков
а не предложений как в языках C или Pascal. Поэтому необходимо
всегда использовать круглые скобки для обозначения блока.

if (EXPR) BLOCK		- Вычисляется логическое выражение EXPR и если true  блок выполняется.

Пример:
	$var =1;
	if ($var == 1)
	   { print $var,"\n";
	   }
Результат: 1


if (EXPR) BLOCK else BLOCK2	-  Если EXPR=true выполняется BLOCK иначе BLOCK2.

Пример:
	$var =2;
	if ($var == 1)
	   { print "\$var = 1\n";
	   }
	else
	   { print "\$var не равно 1\n";
	   }

Результат: $var не равно 1

if (EXPR1) BLOCK1 elsif (EXPR2) BLOCK2 ... else BLOCK	-
	Если EXPR1=true выполняется BLOCK1 иначе если EXPR2=true выполняется
	BLOCK2 иначе ... иначе BLOCK.

Пример:
	$var = 1;
	if ($var == 0)
	   { print "\$var = 0\n";
	   }
	elsif ($var == 1)
	   { print "\$var = 1\n";
	   }
	else
	   { print "Не известное \$var\n";
	   }

Результат: $var = 1

Цикл while выполняет BLOCK до тех пор пока EXPR = true. Метка LABEL не
обязательна и состоит из идентификатора завершающегося символом ':'.
Метка необходима при использовании внутри блока цикла управляющих
операторов next, last и redo. Если метка все же отсутсвует то
эти операторы ссылаются к началу ближайшего цикла.
Блок после continue выполняется всегда перед тем как вычисляется
логическое выражение EXPR. Это подобно EXPR3 в предлжении for
поэтому в этом блоке удобно изменять счетчики и флаги цикла даже
если применяестя оператор next.

<ul><a name=36></a><h2>Операторы управления циклом.</h2></ul>

next	- подобен continue в С. Переходит к началу текущего цикла
	т.е. повторяет итерацию.

Пример:
	M1:
	while ($i &lt; 6)
	    {
	    ++$i;	# Увеличиваем счетчик на 1
	    next M1 if $i &lt; 3; # Переходим в начало если $i &lt; 3
	    ++$i;	# иначе увеличиваем счетчик еще раз на 1
	    }
	continue
	    {
	    print "$i "; # Печатаем $i
	    }

Результат: 1 2 4 6

last	- подобен оператору break в языке С. Немедленно прерывает цикл.
	Блок continue пропускается.

Пример:
        M1:
        while ($i &lt; 6)
            {
            ++$i;       # Увеличиваем счетчик на 1
            last M1 if $i > 3; # Выход из цикла если $i > 3
            ++$i;       # иначе увеличиваем счетчик еще раз на 1
            }
continue {
            print "$i "; # Печатаем $i
}

Результат: 2 4

redo	- начать новый цикл не вычисляя EXPR и не выполняя continue блок.

Пример:
        M1:
        while ($i &lt; 6)
            {
            ++$i;       # Увеличиваем счетчик на 1
            redo M1 if $i == 3; # Далее пропустить для $i = 3
            ++$i;       # иначе увеличиваем счетчик еще раз на 1
            }
continue {
            print "$i "; # Печатаем $i
}

Результат: 2 5 7


<ul><a name=37></a><h2>Цикл for.</h2></ul>

	LABEL for (EXPR1; EXPR2; EXPR3) BLOCK
Оператор for полностью аналогичен оператору for в С. В перед началом
цикла выполняется EXPR1, если EXPR2 = true выполняется блок, затем
выполняется EXPR3.

Пример:
	for ($i = 2; $i &lt; 5; ++$i)
           {
           print $i, " ";
           }
        print "\nПосле цикла i = $i\n";

Результат:
	2 3 4
	После цикла i = 5

<ul><a name=38></a><h2>Цикл foreach.</h2></ul>

	LABEL foreach VAR (LIST) BLOCK

Переменной VAR присваивается поочередно каждый элемент списка LIST
и выполняется блок. Если VAR опущенно то элементы присваиваются
встроеной переменной $_. Если в теле блока изменять значение VAR
то это вызовет изменение и элементов списка т.к. VAR фактически
указывает на текущий элемент списка.
Вместо слова foreach можно писать просто for - это слова синонимы.

Пример:
        @месяц = ("январь","февраль","март");  # Создали массив
        foreach $i (@месяц)
            {
            print $i," ";       # Печать $i
            }

Результат: январь февраль март

Пример:
        @месяц = ("январь","февраль","март");  # Создали массив
        foreach $i (@месяц)
            {
            $i = uc($i); # Перевели в верхний регистр
            }
        print @месяц;

Результат: ЯНВАРЬФЕВРАЛЬМАРТ

Пример:

	for $i (3,5,7)
	    {
	    print "$i ";
	    }
Результат: 3 5 7


<ul><a name=39></a><h2>Блоки и оператор switch.</h2></ul>

Блок не зависимо от того имеет он метку или нет семантически
представляет собой цикл который выполняется один раз. Поэтому
действие опраторов цикла next, last, redo - аналогично описанному
выше. Блоки удобны для построения switch (переключатель) структур.
В пел нет специального оператора switch подобного языку С поэтому
вы сами можете создавать удобные для вас конструкции. Опыт автора
показывает что для простоты написания лучше всего подходит
конструкция вида if ... elsif ... else ... хотя можно сочинить
и нечто подобное:

	SWITCH:
	{
	if ($i ==1 ) { .....; last SWITCH; }
	if ($i ==2 ) { .....; last SWITCH; }
	if ($i ==3 ) { .....; last SWITCH; }
	$default = 13;
	}

Выбирайте сами по своему вкусу.


<ul><a name=40></a><h2>Оператор goto.</h2></ul>

В Пел существует оператор goto хотя где , как и когда его применять
как говорил Ходжа Насредин "Тонкий филосовский вопрос".
Для начинающих программистов которым от так "нужен" я бы вообще
посоветовал "забыть" о его существовании. Однако при создании
больших производственных задач на последнем этапе особенно
при отработке "отвальных" ошибочных ситуаций конечно goto нужен.

В Пел реализовано три формы goto. goto - метка, goto - выражение
и goto - подпрограмма.

goto - метка выполняет непосредственный переход на указанную метку.

goto - выражение - Вычисляет имя метки и делает соответсвующий переход.
	Например если мы хотим сделать переход на одну из трех меток
	"M1:", "M2:" или "M3:" в зависимости от значений переменной
	$i равной 0, 1 или 2 то это лучше сделать следующим образом:

	goto ("M1", "M2", "M3")[$i];

	здесь $i используется как индекс массива указанного непосредственно
	в выражении.

goto подпрограмма - довольно редкий случай т.к. всегда проще и надежней
вызвать подпрограмму "естественным" образом.

<ul><a name=41></a><h2>POD операторы. Документирование программ.</h2></ul>

В Пел реализован очень удобный механизм для написания документации
в момент создания программы. Для этого применяются специальные POD операторы.
Если в теле программы интерпретатор встречает оператор начинающийся
с символа '=' например:

	= head Набор стандартных процедур

то пропускается все до слова '=cut'. Это удобно для включения
длинных на несколько строк или страниц комментариев. Затем
с помощью специальной программы pod можно отделить текст
документации от текста программы.

<ul><a name=42></a><h2> * Переменные * </h2></ul>

В Пел существует три типа структур данных: скаляры, массивы скаляров и
хеши (hashes) - ассоциативные массивы скаляров. Обычно элементы массивов
индексируются целыми числами, первый элемент - нулевой. Отрицательное
значение индекса обозначает номер позиции элемента с конца. Хеши индексируются
строками символов.

Имена скалярных переменных всегда начинаются с символа '$' даже когда
обозначают элемент массива.

<ul><a name=43></a><h2>Пример:</h2></ul>

	$var1		# Простой скаляр 'var1'

	@var1[0]	# Первый элемент массива 'var1'

	$var1{'first'}	# Элемент хэша с индексом 'first'


В случае использования имени массива "целиком" или его "среза"
перед именем массива ставится символ '@'.

<ul><a name=44></a><h2>Пример:</h2></ul>

	@var1		# Все элементы массива var1 ( $var1[0], $var1[1], ... $var1[n])

	@var1[1,3,10]	# Элементы $var1[1], $var1[3], $var1[10]

	@var1{'first','last'} # то же что и ( $var1{'first'}, $var1{'last'} )

Хеш "целиком" начинается с символа '%'.

Пример:

	%var, %key, %years

Имена подпрограмм начинаются символом '&amp;' если из контекста не видно
что это подпрограмма.

Пример:

	&amp;sub1, &amp;test_prog, test(12)

Имена таблиц символов всегда начинаются символом '*'.

Каждый тип переменных имеет свою область памяти поэтому $var1 и $var1[0]
совершенно разные переменные, хотя $var1[0] часть массива @var1. Так же\
@var1 и %var1 - разные массивы переменных.

Имена переменных могут содержать любые буквенно-цифровы символы за исключением
пробела и табуляции. Эти смволы используются в качестве разделителей.
Большие и малые буквы различаются поэтому $var1 и $Var1 - разные
переменные. В Пел по умолчанию имена меток и указателей файлов пишут
большими буквами.

<ul><a name=45></a><h2>Контекст.</h2></ul>

Большое значение для правильного употребления встроенных функций
имеет контекст использования результата этих функций т.к. в противном
случае они возвращают совершенно "непонятный" результат.
В Пел имеется два главных контекста: скалярный и список (list).
Проще говоря если в левой части выражения имеется ввиду одно единственное значение - то
это скалярный контекст. Если множество значений - список.

Пример:

	$var1 = &lt;>;	# Прочитать одну строку файла

	@var1 = &lt;>;	# Прочитать все строки файла в массив @var1

	$var1 = (1,2,3); # $var = 3 - количество элементов

	@var1 = (1,2,3); # Создание массива @var1 с элементами 1,2,3

<ul><a name=46></a><h2>Скалярные значения.</h2></ul>

Все данные в Пел это скаляры, массивы скаляров и хеши скаляров.
Скалярные переменные могут содержать числа, строки и ссылки.
Преобразование числа - строки происходит автоматически по умолчанию.
Скаляр может иметь только одно единственное значение, хотя это
может быть ссылка на массив скаляров. Так -как Пел сам преобразовывает
числа в строки и наоборот то программисту нет необходимости думать
о том что возвращает функция.

В Пел не существует типов "строка" или "число" или "файл" или что то еще.
Это контекстно зависимый полиморфный язык для работы с текстами.

Скаляр имеет логическое значение "TRUE" (истина) если это не нулевая
строка или число не равное 0.

В Пел существует два типа нулевых (null) скаляров - определенные
(defined) и не определенные (undefined). Не определенное значение
возвращается когда что-то не существует. Например не известная
переменная, конец файла или ошибка. С помощью функции defined()
вы можете заранее обнаружить подобное состояние.

Количество элементов массива так же является скаляром и начинается
символами $# подобно интерпретатору csh. Фактически $#var1 - это
индекс последнего элемента массива. Нужно помнить что первый
элемент имеет индкес 0 поэтому количество элементов определяется
как $#var1+1 . Присвоение значения $#var1 - изменит длину
массива и разрушит "оставленные" значения.
Присвоение значения элементу массива с индексом больше чем $#var1
- увеличит размер массива, а присвоение ему нулевого списка -
обнулит.

В скалярном контексте имя массива возвращает его длину (для списка
возвращается последний елемент).

Пример:

	@var1 = (4, 3, 2, 1);	# Присвоение значения элементам массива
	$i = @var1;		# Использование скалярного контекста
	print $i;		# Печать результата 4 - кол-во элементов
	print @var1;		# Списковый контекст, печать всех элементов.

Для принудительного получения скалярного значения удобно применять
функцию scalar().

Пример:

	print scalar(@var1);	# Вывод длины массива а не его значений

Хеш в скалярном контексте возвращает "true" если существует
хотя бы одна пара "ключ-значение". Фактически возвращается строка
типа 2/8 где 8 - количество выделенных "ячеек" памяти а
2 - количество использованных.

Конструкторы скаляров.

Числа пишутся стандартно:

	123
	123.123
	0.12
	.12E-10
	0xABCD		# Шестнадцетиричная запись
	0377		# Если 0 в начале - восьмеричная
	123_456_123	# Так тоже можно для удобства чтения.

Строки ограничиваются одинарными (') или двойными (") кавычками:

	'Ровняйсь, смирно!'
	"Построемся и спасемся."

Способов обозначения строк очень много. Плодробно смотрите описание
оператора qq.
 В хеше можно опускать кавычки если индекс не содержит пробелов.

Пример:

	$var1{first} то же что и $var1{'first'}

Обратите внимание на то что перед первой одинарной кавычкой должен стоять
пробел иначе строка воспримется как имя переменной так-как в именах
разрешено использование одинарных кавычек.
Запрещается в кавычках применять зарезервированные литералы __LINE__
(номер текущей строки программы), __FILE__ (текущий файл).
Для обозначения конца программы можно применять литерал __END__
Весь последующий текст игнорируется, но его можно прочитать использую
указатель файла DATA.

Слова в программе не поддающиеся ни какой интепретации воспринимаются
как строки в кавычках поэтому рекомендуется имена меток и указателей файлов
писать большими буквами для избежания возможного "конфликта" с зарезервированными
словами.

В Пел есть возможность вставлять текст документа прямо в программу.
Так называемый "here-doc" (здесь текст) метод. Обозначается символами
&lt;&lt; за которым идет слово-ограничитель.

Пример:

	print &lt;&lt;EOF;	# Все строки до EOF - текст для печати.

	Эй вы трое, идите двое сюда!

		Полковник Савонькин.
	EOF

<ul><a name=47></a><h2>Конструкторы списков.</h2></ul>

Список - множество значений перечисленных через запятую и заключенных
в круглые скобки. В списковом контексте список возвращает последний
элемент списка.

Пример:

	@var1 = (1, 2, 'привет', 1.2); # Присвоить значение элементам.

где

		$var1[0] = 1,

		$var1[1] = 2,

		$var1[2] = 'привет'

		$var1[3] = 1.2


	$var1 = (1, 2, 'привет', 1.2);

а здесь $var1 = 1.2 т.е. последнее значение списка.

Допускается применять в списке другие списки, но в полученном списке
уже невозможно различить начало и конец включенных списков.

Пример:

	@s1 = (1, 2, 3); # 	Первый список

	@s2 = (6, 7, 8);	# Второй

	@s = (0, @s1, 4, 5, @s2, 9, 10); # Включаем списки @s1 и @s2

	print @s;	# Результат: 012345678910  - значения без пробелов.


Список без элементов обозначаестя как () и называется нуль-списком.
Списковое выражение можно употреблять как имя массива, но при этом
его нужно брать в круглые скобки.

Пример:

	print ('январь','февраль','март')[1];

Результат: февраль

Список может быть присвоен списку только если каждый элемент в списке в
левой части выражения допустим по типу списку в правой части.

Пример:

	($a, $b, $c) = (1, 2, 3); # $a = 1, $b = 2, $c = 3

Присваивание списков в скалярном контексте возвращает количество присвоенных
элементов.

Пример:

	$x = (($a, $b, $c) = (1,2));  # Результат $x=2

В случае присваивания списка хешу список разсматривается как пары: ключ-значение.

Пример:

	%дни_месяца = ('январь', 31, 'февраль', 30);

Результат: $дни_месяца{январь} = 31, $дни_месяца{февраль} = 30

Для удобства записи можно использовать выражение с => .

Пример:

	%дни_месяца = (
			январь => 31,
			февраль => 30,
	);

<ul><a name=48></a><h2>Тип typeglobs</h2></ul>

В Пел используется специальный внутренний тип typeglog для записи
массива всех переменных. Такие массивы начинаются с символа '*'.
Их удобно применять для передачи ссылок на массивы и хеши, но
в данной версии Пел уже есть возможность применять
ссылки поэтому это делается очень редко.
Единственно где это необходимо так это для работы со
ссылками на файлы. Например если вам нужно создать локальную
ссылку на файл в процедуре то это лучше сделать так:

sub new_sub
{ local *IN; # Ссылка на файл
open (IN, "test") || return undef;  # Открыть файл. Возврат при ошибке.
.........
return;
}

Более подробно это описано в главе Ссылки.

<ul><a name=49></a><h2> * Встроенные переменные Пел * </h2></ul>

Описанные в данной главе переменныые имеют в Пел специальные значения.
Они обозначаются несколько непривычно для "глаза" программистов
т.к. состоят обычно только из дву символов причем первый это '$'
символо с которого начинаются имена всех переменных и произвольный часто
не буквенно-цифровой символ. Если вы хотите пользоваться их "нормальными"
буквенными синонимами то вам нужно указать в начале программы:

	use English;

Точно так  же  если вы захотите пользоваться переменными и методами
текущего указателя файлов вы можете написать:

	use FileHandle;

после этого можно можно просто писать:

	метод указатель выражение

или

	указатель -> метод(выражение)


Ниже приводятся имена как в короткой так и в длинной (словесной) форме.
Некоторые из встроенных переменных имеют доступ тоько на чтение
поэтому изменить их значение просто не возможно.

<ul><a name=50></a><h2>$_</h2></ul>

<ul><a name=51></a><h2>$ARG</h2></ul>
	Переменная - по умолчанию для операторов ввода и поиска.
То есть если в качестве аргумента не указана никакая переменная то
используется именно эта.

<ul><a name=52></a><h2>$цифра</h2></ul>
	Содержит найденные подстроку в последнем поиске когда
шаблон содержит метасимволы в круглых скобках. Цифра в данном
случае это номер скобок. Первая подстрока имеет номер 1.

<ul><a name=53></a><h2>$&amp;</h2></ul>
$MATCH
	Найденная подстрока в последнем поиске по шаблону.

<ul><a name=54></a><h2>$`</h2></ul>
	Подстрока предшевствующая найденной подстроке.

<ul><a name=55></a><h2>$'</h2></ul>
$POSTMATCH
	Подстрока последующая за найденной подстрокой.

<ul><a name=56></a><h2>$+</h2></ul>
$LAST_PAREN_MATCH
	Подстрока найденная в поиске с выбором по "или".

<ul><a name=57></a><h2>$*</h2></ul>
$MULTILINE_MATCHING
	Если значение этой переменной установить равным 1 то
переменная в которой осуществляется поиск будет считаться многосторочной
т.е. содержащей символы '\n' - перевод строки. Если значеие равно 0
то переменная считается однострочной. В Пел версии 5 и выше не рекомендуестя
использовать эту переменную.

<ul><a name=58></a><h2>$.</h2></ul>
$INPUT_LINE_NUMBER
$NR
	Номер прочитанной строки последнего оператора ввода.
Закрытие файла вызывает очистку значения этой переменной.

<ul><a name=59></a><h2>$/</h2></ul>
$RS
$INPUT_RECORD_SEPARATOR
	Символ - признак конца входной строки. По умолчанию это '\n'

<ul><a name=60></a><h2>$|</h2></ul>
$OUTPUT_AUTOFLUSH
	Если присвоить этой переменной не нулевое значение то будет
сброс буфера вывода после каждой операции вывода. Значение по умолчанию -0

<ul><a name=61></a><h2>$,</h2></ul>
$OFS
$OUTPUT_FIELD_SEPARATOR
	Символ добавляемый  оператором print после каждого элемента
из списка параметров.

<ul><a name=62></a><h2>$\</h2></ul>
$ORS
$OUTPUT_RECORD_SEPARATOR
	Символ добавляемый print после вывода всех параметров.

<ul><a name=63></a><h2>$"</h2></ul>
$LIST_SEPARATOR
	Анологичен "$," но добавляется после каждого элемента массива
указаноого в "....".

<ul><a name=64></a><h2>$;</h2></ul>
$SUBSEP
$SUBSCRIPT_SEPARATOR
	Символ - разделитель для эмуляции многомерных массивов в хеш
массивах. По умолчанию '\034'.

<ul><a name=65></a><h2>$#</h2></ul>
$OFMT
	Формат по умолчанию для вывода чисел.

<ul><a name=66></a><h2>$%</h2></ul>
$FORMAT_PAGE_NUMBER
	Формат по умолчанию для вывода номеров страниц.

<ul><a name=67></a><h2>$=</h2></ul>
$FORMAT_LINES_PER_PAGE
	Длина одной страницы. По умолчанию 60 строк.

<ul><a name=68></a><h2>$-</h2></ul>
$FORMAT_LINES_LEFT
	Количество оставшихся строк на странице.

<ul><a name=69></a><h2>$~</h2></ul>
$FORMAT_NAME
	Имя формата текущего вывода. По умолчанию имя указателя.

<ul><a name=70></a><h2>$^</h2></ul>
$FORMAT_TOP_NAME
	Имя текущего формата для заголовка страницы.

<ul><a name=71></a><h2>$:</h2></ul>
$FORMAT_LINE_BREAK_CHARACTERS
	Символы переноса строки для многострочных полей. В строке
формата такие поля начинаются символом '^'. По умолчанию '\n-'.

<ul><a name=72></a><h2>$^L</h2></ul>
$FORMAT_FORMFEED
	Символ перевода формата ( смены листа). По умолчанию '\f'.

<ul><a name=73></a><h2>$^A</h2></ul>
$ACCUMULATOR
	Текущее значение аккумулятора функции write() для format().
Значение этой переменной можно увидеть только при использовании
функции formline() т.к. write() очищает ее после каждого вывода.

<ul><a name=74></a><h2>$?</h2></ul>
$CHILD_ERROR
	Данная перменная содержит статус завершения таких процессов
как: закрытие pipe, завершение функций system(), wait() и `...`.

<ul><a name=75></a><h2>$!</h2></ul>
$ERRNO
$OS_ERROR
	В числовом контексте возвращает код ошибки errno.
В строковом - строку сообщения об ошибке. Можно принудительно
присвоить этой перменной код ошибки что бы получить системное
сообщение для данного кода или установить код завершения для
функции die().

<ul><a name=76></a><h2>$@</h2></ul>
$EVAL_ERROR
	Сообщение об ошибке последней команды eval().

<ul><a name=77></a><h2>$$</h2></ul>
$PID
$PROCESS_ID
	Номер текущего процесса.

<ul><a name=78></a><h2>$&lt;</h2></ul>
$UID
$REAL_USER_ID
	Реальный UID текущего процесса.

<ul><a name=79></a><h2>$></h2></ul>
$EUID
$EFFECTIVE_USER_ID
	Эффективный UID текущего процесса.

<ul><a name=80></a><h2>$(</h2></ul>
$GID
$REAL_GROUP_ID
	Реальный GID текущего процесса.

<ul><a name=81></a><h2>$)</h2></ul>
$EGID
$EFFECTIVE_GROUP_ID
	Эффективный GID текущего процесса.

<ul><a name=82></a><h2>$O</h2></ul>
$PROGRAM_NAME
	Имя файла программы. Если этой переменной присвоить какое
нибудь значение то его можно видеть в команде ps, что удобно для
контроля за состоянием программы.

<ul><a name=83></a><h2>$[</h2></ul>
	Номер первого элемента массива или символа строки.
Значение по умолчанию - 0.

<ul><a name=84></a><h2>$]</h2></ul>
$PERL_VERSION
	Строка сообщение версии Пел. Печатается по команде perl -v
Применяется в программе для определения рабочей версии Пел.
В числовом контексте это номер версии плюс номер модификации / 1000.

<ul><a name=85></a><h2>$^D</h2></ul>
$DEBUGGING
	Текущее значение ключа отладки '-D'.

<ul><a name=86></a><h2>$^F</h2></ul>
$SYSTEM_FD_MAX
	Номер максимального системного описателя файлов (system file
descriptor). Обычно это 2.

<ul><a name=87></a><h2>$^I</h2></ul>
$INPLACE_EDIT
	Текущее значение inplace-edit возможности.
Для отключения используйте undef.

<ul><a name=88></a><h2>$^P</h2></ul>
$PERLDB
	Внутренний флаг отладки. Применяется для того что бы отладчик
не отслеживал самого себя.

<ul><a name=89></a><h2>$^T</h2></ul>
$BASETIME
	Время в секундах с начала 1970 года старта текущей программы.

<ul><a name=90></a><h2>$^W</h2></ul>
$WARNING
	Значение флага '-w'. true -если включено и false - выключено.

<ul><a name=91></a><h2>$^X</h2></ul>
$EXECUTABLE_NAME
	Команда запуска Пел. Аналогично argv[0] в С.

<ul><a name=92></a><h2>$ARGV</h2></ul>
	Имя текущего файла читаемого оператором '&amp;lt;>'.

<ul><a name=93></a><h2>@ARGV</h2></ul>
	Массив параметров строки запуска программы.
Внимание! @#ARGV - меньше количества параметров на 1 т.к.
$ARGV[0] это первый параметр (не имя программы).

<ul><a name=94></a><h2>@INC</h2></ul>
	Список директорий диска которые просматривает Пел
для выполнения команд do, require или use.

<ul><a name=95></a><h2>%INC</h2></ul>
	Этот хеш содержит имена директорий для имен использованных
файлов командами do или require. Ключ - имя файла, а значение - директория.

<ul><a name=96></a><h2>$ENV{выражение}</h2></ul>
	Хеш %ENV содержит значения переменных окружения. Изменение
этих значений вызывает изменение окружения для процессов потомков.

<ul><a name=97></a><h2>$SIG{выражение}</h2></ul>
	Хеш %SIG содержит имена подпрограмм для системных
сигналов таких как INT, QUIT, PIPE, ...
Значение 'DEFAULT' - для системной обработки.
'IGNORE' - игнорировать данный сигнал.

<ul><a name=98></a><h2> * Регулярные выражения (шаблоны) * </h2></ul>

В данной главе описывается синтаксис регулярных выражений. Чаще всего
в Пел они используюстя в операторах поиска и замены таких как s//
m/ операторах связки =~ или != и т.д.
Как правило все эти операторы имеют схожие опции такие как:

	i	- не различать строчные и заглавные буквы.
	m	- считать строку многострочной.
	s	- однострочная строка.
	x	- расширенный синтаксис ( использование пробелов и комментариев)

Обычно все эти опции обозначают как '/x'. Их можно использовать даже
внутри шаблонов, используя новую конструкцию (?...)

Регулярные выражения или шаблоны (pattern) то же самое что и regexp
процедуры в Юниксе. Выражения и синтаксис заимствован из свободно
распространяемых процедур V8 Генри Спенсера (Henry Spencer) там же
они подробно и описаны.

В шаблонах используются следующие метасимволы (символы обозначающие
группы других символов) часто называемых egrep - стандартом:

	\	- считать следующий метасимвол как обычный символ.
	^	- начало строки
	.	- один произвольный символ. Кроме '\n' - конец строки.
	$	- конец строки
	|	- альтернатива (или)
	()	- группировка
	[]	- класс символов

Метасимволы имеют модификаторы (пишутся после метасимвола):

	*	- повторяется 0 или большее число раз
	+	- повторяется 1 или большее число раз
	?	- 1 или 0 раз
	{n}	- точно n раз
	{n,}	- по меньшей мере раз
	{n,m}	- не менше n, но и не больше m

Во все других случаях фигурные скобки считаются обычными (регулярными)
символами. Таким образом '*' эквивалентна {0,} , '+' - {1,}
и '?' - {0,1}. n и m не могут быть больше 65536.

По умолчанию действие метасимволов "жадно" (greedy). Совпадение
распространяется столько раз сколько возможно не учитывая результат
действия следуюющих метасимволов. Если вы хотите "уменьшить их аппетит"
то используйте символ '?'. Это не изменяет значение метасимволов
просто уменьшает распространение. Таким образом:

	*?	- станет 0 и более
	+?	- 1 и более
	??	- 0 или 1 раз
	{n}?	- точно n раз
	{n,}?	- не меньше n раз
	{n,m}?	- больше или равно n и меньше m раз

Шаблоны работают так же как и двойные кавычки поэтому в них можно
использовать `\` - символы (бакслэш-символы):

	\t	- символ табуляции
	\n	- новая строка
	\r	- перевод каретки
	\A	- перевол формата
	\v	- вертикальная табуляция
	\a	- звонок
	\e	- escape
	\033	- восьмеричная запись символа
	\x1A	- шестнадцатеричная
	\c[	- control символ
	\l	- нижний регистр следующего символа
	\u	- верхний регистр -//-
	\L	- все символы в нижнем регистре до \E
	\U	- в верхнем -//-
	\E	- ограничитель смены регистра
	\Q	- отмена действия как метасимвола

Дополнительно в Пел добавлены следующие метасимволы:

	\w	- алфавитно-цифровой или '_' символ
	\W	- не алфавитно-цифровой или '_' символ
	\s	- один пробел
	\S	- один не пробел
	\d	- одна цифра
	\D	- одна не цифра

Обратите внимание что все это "один" символ. Для обозначения последовательности
применяйте модификаторы. Так:

	\w+	- слово
	\d+	- целое число
	[+-]?\d+	- целое со знаком
	[+-]?\d+\.?\d*	- число с точкой

Кроме того существуют мнимые метасимволы. Обозначающие не существующие
символы в месте смены значения. Такие как:

	\b	- граница слова
	\B	- не граница слова
	\A	- начало строки
	\Z	- конец строки
	\G	- конец действия m//g

Граница слова (\b) - это мнимая точка между символами \w и \W.
Внутри класса символов '\b' обозначает символ backspace (стирания).
Метасимволы \A и \Z - аналогичны '^' и '$' но если началостроки '^'
и конец строки '$' действуют для каждой строки в многосторочной строке
то \A и \Z обозначают начало и конец всей многосторчной строки.

Если внутри шаблона применяется группировка (круглые скобки)
то номер подстроки группы обозначается как '\цифра'.
Заметьте что за шаблоном в пределах выражения или блока эти группы обозначаются
как '$цифра'. Кроме этого существуют дополнительные переменные:

	$+	- обозначает последнее совпадение
	$&amp;	- все совпадение
	$`	- все до совпадения
	$'	- все после совпадения

Пример:

$s = "Один 1 два 2 и три 3";
if ($s =~ /(\d+)\D+(\d+)/)
    {
        print "$1\n";	# Результат '1'
        print "$2\n";	# '2'
        print "$+\n";	# '2'
        print "$&amp;\n";	# '1 два 2'
        print "$`\n";	# 'Один '
        print "$'\n";	# ' и три 3'
   }


<ul><a name=99></a><h2>Пел версии 5 содержит дополнительные конструкции шаблонов:</h2></ul>

(?#комментарий)	- комментарий в теле шаблона.

	(?:шаблон)	- группировка как и '( )' но без обратной ссылки

	(?=шаблон)	- "заглядывание" вперед. Например /\w+(?=\t)/
			соответствует слову за которым идет табуляция
но символ '\t' не включается в результат.

Пример:
$s = "1+2-3*4";
if ($s =~ /(\d)(?=-)/)  # Наити цифру за которой стоит '-'
    {
        print "$1\n";   # Результат '2'
   }
else { print "ошибка поиска\n";}


	(?!шаблон)	- "заглядывание" вперед по отрицанию.

Пример:
$s = "1+2-3*4";
if ($s =~ /(\d)(?!\+)/) # Наити цифру за которой не стоит '+'
    {
        print "$1\n";   # Результат '2'
   }
else { print "ошибка поиска\n";}


	(?ismx)	- "внутренние" модификаторы. Удобно применять в шаблонах
	где например нужно внутри шаблона указать модификатор.


<ul><a name=100></a><h2>Правила регулярного выражения. (regex)</h2></ul>

	1. Любой символ обозначает себя самого если это не метасимвол.
	Если вам нужно отменить действие метасимвола то поставьте
	перед ним '\'.
	2. Строка символов обозначает строку этих символов.

	3. Множество возможных символов (класс) заключается в квадратные
	скобки '[]' это значит что в данном месте может стоять один
	из указанных в скобках символ. Если первый символ в скобках
	это '^' - значит не один из указанных символов не может
	стоять в данном месте выражения. Внутри класса можно употреблять
	символ '-' обозначающий диаппазон символов. Например a-z
	один из малых букв латинского алфавита, 0-9 - цифра и т.д.

	4. Все символы, включая специальные можно обозначать с
	помощью '\' как в языке С.

	5. Альтернативные последовательности разделяются символом '|'
	Заметьте что внутри квадратных скобок это обычный символ.

	6. Внутри регулярного выражения можно указыват "подшаблоны"
	заключая их в круглые скобки и ссылаться на них как '\номер'
	Первая скобка обозначается как '\1'.

<ul><a name=101></a><h2> * Операторы и приоритеты * </h2></ul>

     В   Пел   ассоциативность   и   приоритетность  операторов
аналогична  языку C. Ниже перечислены  все  операторы в порядке
уменьшения приоритета, в начале строки указана ассоциативность.

	ассоц.	    операторы
	-----	---------------------------
	левая	термы и левосторонные списковые операторы
	левая	->
	 -	++ --
	правая	**
	правая	! ~ \ унарные + и -
	левая	=~ !~
	левая	* / % x
	левая	+ - .
	левая	&lt;&lt; >>
	  -	именованные унарные операторы
	  -	&lt; > &lt;= >= lt gt le ge
	  -	== != &lt;=> eq ne cmp
	левая	&amp;
	левая	| ^
	левая	&amp;&amp;
	левая	||
	  -	..
	правая	?:
	правая	= += -= *= и т.д.
	левая	, =>
	  -	правосторонние списковые операторы
	левая	not
	левая	and
	левая	or xor


<ul><a name=102></a><h2>Термы и левосторонние списковые операторы.</h2></ul>

Любой терм имеет самый высокий приоритет. К терму относятся
переменные, кавычки и их операторы, арифметические и логические выражения
в скобках, любые функции с параметрами в скобках. Фактически таких
функций нет так как это просто унарные и списковые операторы просто
они ведут себя подобно функциям с параметрами в скобках. Подробно смотри
главу "Функции".
Если после любого спикового оператора ( print(), и т.д.) или унарного
оператора (chdir(), и т.д.) следует левая круглая скобка, то операторы
внутри скобок имеют наивысший приоритет. Так же как и обычные функции.

Если скобки отсутсвуют то приоритет списковых операторов или наивысший
или наименьший в отношении операторов справа или слева от него.

Например:

        @i = ('a ','b ', print 'c ', 'd ');
        print "\n",@i,"\n";

Результат:
	c d
	a b 1

Здесь мы имеем списковый оператор print. Для запятых слева от него он
имеет наименьший приоритет, но повышает приоритет правой запятой.
Поэтому правая запятая воспринимается как параметр для print и печатается
'c d' а левая просто записывает код завершения операции в массив @i
и последний print показывает это.

<ul><a name=103></a><h2>Оператор '->'</h2></ul>

Так же как в С или С++ это инфиксный оператор переадрессации. Если
справа от него стоит [...] или {...} выражение, то правая часть может
быть непосредственной или символической ссылкой на массив или хеш.
В противном случае правая сторона это метод или простой скаляр содержащий
имя метода, а правая или объект или имя класса. Подробно смотри
главу "Классы".

<ul><a name=104></a><h2>Операторы ++ (инкремент) и -- (декремент).</h2></ul>

Эти операторы работают так же как и в С. Если оператор стоит перед
переменной то значение переменной изменяется на 1 и полученной значение
используется. Если после переменной то ее величина изменяется после
применения.

Употребление инкремента к строковым переменным в Пел имеет одну особенность.
Каждый символ остается в своем классе (большие, малые, цифры) и учитывается
перенос предыдущего символа. Таким образом строковые переменные с цифрами
работают как числовые переменные.

Пример:
	print ++($i = "09");	# Результат "10"

	print ++($i = "a9");	# "b0"

	print ++($i = "az");	# "ba"

	print ++($i = "aZ");	# "bA"

<ul><a name=105></a><h2>Оператор ** (возведение в степень)</h2></ul>

Пример:
	print 4**2	# Результат 16

	print -4**2	# Результат -16 т.е. -(4**2)

<ul><a name=106></a><h2>Унарные операторы.</h2></ul>

	'!'	- логическое отрицание

	'-'	- арифметический минус

	'~'	- побитная инверсия (дополнение до 1)

	'+'	- арифметический плюс

	'\'	- получение ссылки на переменную (как &amp; в С)

<ul><a name=107></a><h2>Операторы "привязки" =~ и !~ .</h2></ul>

     Эти  "необычные"  я  бы  даже сказал оригинальные операторы имеют очень
широкое применение в Пел. Можно даже  назвать  их  "оригинальным"  решением.
Оператор  =~ логически связывает левую часть выражения с патерном (pattern -
образец, шаблон, модель) в правой.  По  умолчанию  поиск  или  изменение  по
патерну  выполняется в переменной $_ Операторы привязки позволяют делать это
с любой переменной указанной в левой  части.  Логическим  результатом  будет
успех  операции.   Если в правой части вместо патерна присутсвует выражение,
то результат этого выражения воспринимается как патерн. Однако это не  очень
эффективно  т.к.  патерн будет компилироваться во время исполнения программы
что  заметно  снизит  быстродействие.   Оператор  !~  аналогичен  =~  только
результат  совпадения инвентируется (логическое "нет"). Подробное применение
этих операторов приводится в главе "Патерны".

<ul><a name=108></a><h2>Мультипликативные операторы.</h2></ul>

	'*'	- арифметическое умножение

	'/'	- арифметическое деление

	'%'	- арифметический модуль

	'x'	- оператор повторения
В скалярном контексте возвращает строку левой части повторенную величиной
указанной в правой части. В списковом контексте, если в левой части список
в круглых скобках - повторенный список.

Пример:
	print '*' x 5;	# Результат '*****'

	print (1,2) x 3; # Результат 121212


<ul><a name=109></a><h2>Аддитивные операторы.</h2></ul>

	'+'	- арифметический плюс

	'-'	- арифметический минус

	'.'	- конкатенация (объединение) строк

<ul><a name=110></a><h2>Операторы сдвига.</h2></ul>

	'&lt;&lt;'	- Сдвигает побитно влево значение выражения в левой части
		на количество бит указанное в правой.

	'>>'	- Сдвигает побитно вправо значение выражения в левой части
		на количество бит указанное в правой.

<ul><a name=111></a><h2>Именованные унарные операторы.</h2></ul>

Фактически это функции с одним аргументом. Круглые скобки можно опускать.

<ul><a name=112></a><h2>Операторы отношений.</h2></ul>

	'&lt;'	- арифметическое меньше

	'>'	- арифметическое больше

	'&lt;='	- арифметическое меньше или равно

	'>='	- арифметическое больше или равно

	'lt'	- строковое меньше

	'gt'	- строковое больше

	'le'	- строковое меньше или равно

	'ge'	- строковое больше или равно

<ul><a name=113></a><h2>Операторы равенства.</h2></ul>

	'=='	результат true если левая часть равна правой (равно)

	'!='	- не равно

	'&lt;=>'	- -1 если левая часть меньше правой, 0 если равна,
		1 если больше.

	'eq'	- строковое равно

	'ne'	- строковое не равно

	'cmp'	- как и '&lt;=>' применительно к строкам

<ul><a name=114></a><h2>Операторы работы с битами.</h2></ul>

	'&amp;'	- побитное AND

	'|'	- побитное OR

	'^'	- побитное XOR

<ul><a name=115></a><h2>Логические операторы &amp;&amp; (AND) и || (OR).</h2></ul>

	'&amp;&amp;'	- если левое выражение возвращает false, правое не выполняется.

	'||'	- если левое выражение возвращает true, правое не выполняется.

Отличие от подобных операторов в С заключается в том, что в С возращаемое
значение либо 0 либо 1. Тогда как в Пел возвращается результат выражения.

<ul><a name=116></a><h2>Оператор диапазона '..'</h2></ul>

     Результат работы данного оператора зависит от контекста. В
списковом контексте результат есть список с элементами.  Первый
элемент  которого  это  левое  выражение  и последнее - правое.
Значение каждого элемента внутри  списка  увеличивается  на  1.
Данный   оператор  удобен  для  небольших  циклов  т.к.  память
отводится для всего списка целиком. Поэтому будьте  внимательны
и не задавайте слишком большой диаппазон.
 Пример:
	for $i (1..4)
	   { print "$i ";
	   }
Результат: 1 2 3 4

В скалярном контексте результат - логическое значение. Каждая '..'
операция устанавливает свое собственное состояние. Это false
до тех пор пока левый операнд false. Как только левый операнд
стал true результат - true до тех пока правый true, после чего
результат опять - false. Если вы не хотите проверять правый операнд
то используйте оператор '...'.
Правый операнд не вычисляется пока результат false и  левый
операнд не вычисляется пока пока результат true. Приоритетность
оператора '..' немного ниже чем '&amp;&amp;' и '||'. Возвращаемое
значение если flase - нулевая строка, если true - порядковый номер
начиная с 1. Порядковый номер обнуляется для каждого нового диаппазона.
Последний порядковый номер добавляется строкой "E0" которая не изменяет
его значение но позволяет фиксировать последнее значение.

Пример:
	@алфавит = ('a'..'z'); # Массив малых букв латинского алфавита

	@цифры = (0..9);	# Массив цифр

Условный оператор '?:'

Этот оператор работает так же как и в С. Если выражение перед '?'
истинно то выполняется аргумент перед ':' - иначе после ':'.

Пример:
	$i = 1;
	$i > 1 ? print "больше" : print "меньше";

Результат: меньше

<ul><a name=117></a><h2>Операторы присваивания.</h2></ul>

	'='	- обычный оператор "присвоить" правое значение переменной слева
Вся эта группа операторов подобна операторам С т.е.

	$i += 2;
эквивалентно
	$i = $i + 2;
Остальные операторы этой группы работают аналогично.
Допустимы следующие операторы:

	**=
	+=	-=	.=
	*=	/=	%=	x=
	&amp;=	|=	^=
	&lt;&lt;=	>>=
	&amp;&amp;=	||=

Приоритет всей этой группы операторов равен приоритету '='.


<ul><a name=118></a><h2>Оператор ',' (запятая)</h2></ul>

В скалярном контексте выполняется левый аргумент, результат игнорируется
затем правый и его результат есть результат действия оператора.
В списковом контексте это разделитель элементов списка который
включает указанные элементы в список.

<ul><a name=119></a><h2>Оператор логическое not (орицание).</h2></ul>

Унарный not возвращает противоположное значение полученное выражением
справа. Он эквивалентен '!' но имеет очень низкий приоритет.

<ul><a name=120></a><h2>Оператор логическое and (И).</h2></ul>

Выполняет логическую конъюнкцию двух выражений. Эквивалентен '&amp;&amp;'
но имеет очень низкий приоритет и "краткость" действия. т.е
если левое выражение равно false - левое не выполняется.

<ul><a name=121></a><h2>Логическое or (ИЛИ).</h2></ul>

Выполняет логическую дизъюнкцию двух выражений. Эквивалентен '||'
но имеет очень низкий приоритет и "краткость" действия. т.е
если левое выражение равно true - левое не выполняется.

Логическое xor (исключающее ИЛИ).
Выполняет логическое исключающие или. Всегда выполняются оба
правое и левое выражение.

<ul><a name=122></a><h2>С операторы отсутствующие в Пел.</h2></ul>
 В Пел отсутсвуют операторы языка С такие как:
	унарное &amp;	- получить адрес. Для этого применяется '\'.

	унарный *	- переадресация.

	(TYPE)		- совмещение типов.


<ul><a name=123></a><h2>Операторы ограничители строк.</h2></ul>

Обычно ограничители строк мы считаем литералами, но в Пел это операторы
выполняющие разного рода интерполяцию и поиск по шаблону. Вы можете
сами задавать удобные для вас ограничители. В следующей таблице
приведен полный перечень вариантов. Фигурные скобки '{}' обозначают
любой символ используемый для ограничителя. В случае использования
скобок (круглых '()', квадратных '[]', фигурных '{}', угловых '&lt;>')
в начале ставится открывающаяся скобка а в конце закрывающая.

  По умолчанию	Полное	Функция     Интерполяция
   ----------	------	------------	----
	''	q{}	Literal		нет
	""	qq{}	Литерал		да
	``	qx{}	Команда		да
		qw{}	Список слов	нет
	//	m{}	Шаблон		да
		s{}{}	Подстановка	да
		tr{}{}	Трансляция	нет

В строках допускающих интерполяцию имена переменных начинающиеся с
символов '$' или '@' - интерполируются т.е. в строку вставляется
значение строки или массива.
Данные последовательности символов имеют специальное значение:

	\t	символ табуляции
	\n	символ новой строки
	\r	возврат
	\f	перевод формата
	\v	вертикальная табуляция
	\b	backspace (забой)
	\a	звонок
	\e	escape
	\034	восьмеричный символ
	\x1a	шестьнадцатеричный символ
	\c[	символ управления
	\l	нижний регистр следующего символа
	\u	верхний регистр следующего символа
	\L	нижний регистр для всех символов до \E
	\U	верхний регистр для всех символов до \E
	\E	ограничитель смены регистра
	\Q	отмена действия метасимволов до \E

Шаблоны интерполируются как регулярные выражения. Это выполняется
вторым проходом после интерполяции переменных поэтому
в шаблоны можно вставлять переменные. Для отмены интерполяции
используйте '\Q'. Если вы применяете вложенные ограничители то
внутренние ограничители работать не будут.

<ul><a name=124></a><h2>?PATERN?</h2></ul>
Действие этого оператора аналогично /шаблон/ но выполняется
до первого совпадения. Это удобно для поиска наличия какой
нибудь строки в одном или множестве файлов. Это не очень
удачный оператор поэтому в следующих версиях Пел его
возможно не будет.

<ul><a name=125></a><h2>m/PATERN/gimosx</h2></ul>
/PATERN/gimosx
Поиск в строке по патерну (шаблону). В скалярном контексте возвращает
логическое значение true (1) или false (''). Если строка не указана
с помощью операторов '=~' или '!~' поиск ведется в строке $_

Опции:
	g	- Глобальный поиск. Поиск всех вхождений.
	i	- Сравнение не зависит от регистра (верхний или нижний)
	m	- Строка многострочна.
	o	- однопроходная компиляция
	s	- однострочная строка
	x	- используеются расширенные регулярные выражения.

Если '/' - ограничитель то начальное 'm' можно опустить. С помощью
него в качестве ограничителя может быть любой символ кроме пробела.

PATTERN может содержать переменные которые будут интерполироваться
(перекомпилироваться) каждый раз в момент вычисления.
Переменные $) и $| не интерполируются. Если вы хотите что бы
такой шаблон интерполировался один раз - добавьте /o.
Это необходимо делать в циклах поиска для увеличения быстродействия
однако если вы измените значение переменной Пел этого даже не заметит.

Если PATERN - нулевая строка то используется последнее регулярное
выражение.

В скалярном контексте возвращается список элементы которого
результаты выполнения выражений в скобках патерна ($1, $2, $3...).
Обратите внимание что первый елемент $1.

Пример:
	$a = "/usr/local/perl/perl.bin"; # Анализируемая строка

Цель:	Создать массив @dirs с именами директорий.

Решение:
	Самый простой способ воспользоваться split('\/')
	но в качестве примера используем скобки.

	@dirs =~ m[/(\w*)/(\w*)/(\w*)/(\w*)]

Здесь 'm[' - использовать квадратные скобки как ограничители.
(\w*)	- шаблон алфавитноцифровой последовательности.

В результате @dirs равен ('usr', 'local', 'perl')

<ul><a name=126></a><h2>q/строка/</h2></ul>
'строка'
	Строка литералов. Не интерполируется. Внутри строки разрешается использовать
\' или \\ для обозначения символов ' и \ .

Пример:
	print q#Привет.#;	# Результат Привет.

	print 'O\'K';		# O'K

qq/строка/
"строка"
	Интерполируемая строка.

Пример:
	$var = 13;
	print "\$var = $var";

Результат:
	$var = 13

<ul><a name=127></a><h2>qx/строка/</h2></ul>
`строка`
	Сначало строка интерполируется а потом выполняется как
	системная команда.

Пример:
	print `date`;

Результат:
	Thu Nov 14 13:36:49 MSK 1996

<ul><a name=128></a><h2>qw/строка/</h2></ul>
	Возвращает список элементы которого - слова строки разделенные
	пробелами.

Пример:
	print qw/Построемся и спасемся!/; # ('Построемся','и','спасемся!')

Результат:
	Построемсяиспасемся!

Часто применяется как:
	use POSIX qw( setlocale localeconv )
	@EXPORT = qw( proc1 var );

<ul><a name=129></a><h2>s/шаблон/подстрока/egimosx</h2></ul>
	Поиск по шаблону и в случае успеха замена подстрокой.
	Возвращает количество произведенных подстановок иначе false (0).
Если строка в которой ведестя поиск не указана (операторы =~ или != )
то используется переменная $_ .
Если в качестве раделителя '/' исрользовать одинарную кавычку (')
то интерполяции не будет иначе можно применять переменные в шаблоне
или подстроке.

Опции:

	e	- Расмматривать правую часть как выражение.
	g	- Глобальный поиск.
	i	- Без различия регистра букв
	m	- многосточная переменная
	o	- компилировать шаблон один раз
	s	- однострочная переменная
	x	- расширенное регулярное выражение

Разделитель '/' можно заменить на любой алфавитно-цифровой символ
кроме пробела.

Пример:
	$var = "12345"; # исходная строка
	$var =~ s/1/0/; # Заменить '1' на '0'. Результат 02345
	$var =~ s(5)(.); # Заменить '5' на '.' Результат 0234.

Здесь в качестве разделителя применены скобки поэтому подстрока
взята в две скобки.

	$var =~ s/\d*/каламбур/; Заменить все цифры. Результат 'каламбур.'

	$var =~ s/а/о/g; # Заменить все 'а' на 'о'. Результат 'коломбур.'

	$var = "12 34"; # Новое значение

	$var =~ s/(\d\d) (\d\d)/$2 $1/; # Поменять местами числа. Результат '34 12'.


<ul><a name=130></a><h2>tr/таблица1/таблица2/cds</h2></ul>
y/таблица1/таблица2/cds

	Замена всех символов из "таблица1" на соответсвующий символ
из "таблица2". Результат - количество замен или стираний. Без оператора
=~ или != операция выполняется с строкой $_. Для совместимости с программой
sed вместо tr можно писать 'y'.

Опции:
	c	- дополнение "таблица1"
	d	- стереть найденные но не замененные символы.
	s	- "зжать" повторяющиеся замененные символы.

Если указана опция /d таблица2 всегда интерпретируется как положено.
Другими словами если таблица2 короче чем таблица1 то символ из таблицы1
интерпретируется всегда. Если таблица2 - null то все символы строки
остаются не изменненные. Это удобно для подсчета количества сиволов
в строке определенного класса или для сжатия повторяющихся символов
например пробелов.

Пример:
	$s = "hello";	# Исходная строка

	$s =~ tr/a-z/A-Z/;	# Заменить малые буквы на большие. Результат
				# 'HELLO'

	$s = 'Hel....lo';
	$s =~ tr/a-zA-z/_/c;	# Заменить все не буквы на '_'
				# Результат 'Hel____lo'
	$s =~ tr/_/ /s;		# Заменить '_' на ' ' и сжать.
				# Результат 'Hel lo'
	$s =~ tr/a-zA-Z /a-zA-Z/d; # Удалить все не буквы. Результат 'Hello'

Если один и тот же символ несколько раз указан в таблице1 то применяется
только первая замена.


<ul><a name=131></a><h2>Операторы ввода-вывода.</h2></ul>

В Пел существует несколько операторов ввода-вывода. Первый это скобки
из символа '`' - акцента. Строка в этих скобках воспринимается как
системная команда и результат ее действия возвращается как "псевдо"
литерал. В скалярном контексте это строка содержащая весь результат,
а в списковом - список элементы которого - строки результата.
Статус выполненой команды хранится в переменной $? .

Следующая команда ввода вывода выгледит как '&lt;файл>'.
Вычисление &lt;файл> приводит к чтению строки из файла. Обратите внимание
что 'файл' здесь не имя файла а указатель файла который создается
функцией open(). В скалярном контексте читается одна строка вместе
с символом '\n' - перевода строки, а в списковом весь файл читается
в список элементы которого суть строки файла.
В случае обнаружения конца файла результат оператора не определен
и воспринимается как false. Если не указана переменная результата
то по умолчанию это $_. Указатель файла по умолчанию STDIN -
стандартный ввод.

Пример:
	while(&lt;>) { print; }; # Прочитать и вывести весь файл STDIN

У оператора '&lt;>' есть одна отличительная особенность. Если в командной
строке нет никаких аргументов то читается стандартный ввод, если
есть аргументы то они считаются именами файлов которые последовательно
читаются.
Если в угловых скобках записана переменная то содержимое этой
переменной считается именем указателя файла или ссылкой на
указатель файла. Если такого указателя не существует то содержимое
переменной воспринимается как шаблон имен файлов и результат
- имена файлов на диске подходящих по шаблону.

Пример:
	while(&lt;*.pl>) { print;}; # То же что и ls *.pl

	@files = &lt;*>;	# Массив @files содержит имена файлов в директории

но лучше сделать: @files = glob("*"); т.к. внутри скобок можно использовать
переменные.


<ul><a name=132></a><h2>Слияние констант.</h2></ul>

Как и С Пел выполняет возможные вычисления в период компиляции.
Так подстановка символов после '\' , операция конкатенации строк,
арифметические выражения содержащие только одни константы, все это
делается в момент компиляции что существенно увеличивает скорость
выполнения программы.

<ul><a name=133></a><h2>Целочисленная арифметика.</h2></ul>

По умолчанию Пел выполняет арифметику с плавающей запятой, но
если вы укажете:

	use integer;

то компилятор будет использовать целочисленную арифметику до
конца текущего блока, хотя вложенный блок может это и отменить
в своих пределах с помощью:

	no integer;

<ul><a name=134></a><h2> * Встроенные функции * </h2></ul>

     Встроенные  функции  используются  как  термы  выражений и
подразделяются на две категории: списковые операторы и  унарные
операторы.  Это влияет на их приоритет по отношению к оператору
',' - запятая.   Списковые  операторы  могут  именть  множество
(список)  аргументов,  а  унарные  только  один.  Таким образом
запятая завершает  аргументы  унарного  оператора  и  разделяет
аргументы спискового.
     Аргумент   унарного   оператора  воспринимается  обычно  в
скалярном  контексте  а  спискового  как  в  скалярном  так   и
списковом  причем скалярные аргументы идут первыми. В дальнешем
списковые аргументы  мы  будем  обозначать  словом  'LIST'  это
значит что функция имеет список аргументов разделенных запятой.
Аргументы функций можно заключать  в  круглые  скобки  и  таким
образом  обозначать  что  "это  функция"  и  приоритет не имеет
значения  иначе  это   списковый   или   унарный   оператор   с
определенным  фиксированным  приоритетом.  Пробел  после  имени
функции  и  скобкой  значения   не   имеет.    Поэтому   будьте
внимательны!

Пример:
	print 1 + 2 + 3; # результат 6

	print(1+2)+3;	# результат 3

	print (1+2)+3;	# опять 3

	print (1+2+3);	# 6

Если функция возвращает результат как в скалярном так и в списковом контексте
то код выхода по ошибке - скаляр c неопределенным значением или пустой
список.

Запомните правило:

	Не существует общего правила преобразования списка в скаляр!

Каждый оператор и функция имеют свой вид значения в скалярном котексте.
Для одних это количество элементов из скалярного контекста. Для других
первый элемент списка или последний или количество
успешных операций. Каждый свое если вы специально не указываете.

<ul><a name=135></a><h2>Оператор '-X'.</h2></ul>

	-X указатель файла
	-X выражение
	-X

Проверка файла, где 'X' одно из ниже описанных значений.
Это унарный оператор с одним аргументом - либо именем файла либо
указателем файла. Проверяет одно из условий. Если аргумент не указан
то берется значение переменной $_. Для ключа -t STDIN.
Результат 1 если true и '' если false или неопределенное значение
если файл не найден. Несмотря на странный вид это унарный оператор
с соответсвующим приоритетом. Аргумент можно заключать в круглые скобки.
'X' имеет следующие значения:

	-r	Файл разрешен на чтение эффективным uid/gid
	-w	на запись -//-
	-x	исполнение -//-
	-o	принадлежит эффективному uid (идентификатор пользователя)

	-R	Файл разрешен на чтение реальным uid/gid
	-W	на запись -//-
	-X	исполнение -//-
	-O	принадлежит реальному uid

	-e	файл существует
	-z	пустой
	-s	не пустой

	-f	обычный текст
	-d	директория
	-l	символическая ссылка
	-p	pipes (конвейер)
	-S	socket (гнездо)
	-b	специальное блочное устройство
	-c	-//- символьное -//-
	-t	указатель на уст-во tty

	-u	установлен бит setuid
	-g	-//- setgid
	-k	-//- sticky

	-T	текстовой файл
	-B	двоичный

	-M	"возраст" файла в днях на момент старта скрипта
	-A	дней с последнего чтения
	-C	дней с последней модификации inode


<ul><a name=136></a><h2>abs выражение</h2></ul>

        Абсолютное значение выражения

<ul><a name=137></a><h2>accept NEWSOCKET, GENERICSOCKET</h2></ul>

	Окрыть новый сокит по внешнему запросу. Аналогично
системному вызову accept(). Возвращает адрес или false в случае
неудачи.

<ul><a name=138></a><h2>alarm секунды</h2></ul>

	Послать сигнал SIGALARM текущиму процессу
по истечении указанного промежутка времени. Не допустимо делать
несколько вызовов одновременно в одном промежутке времени.
Возвращает остаток времени предыдущего счетчика.

<ul><a name=139></a><h2>atan2 Y, X</h2></ul>

	Арктангес отношения Y к X в пределах от -pi до +pi.

<ul><a name=140></a><h2>bind сокит, имя</h2></ul>

	Назначить сетевой адрес сокиту. Подобно системному
вызову bind. Возвращает true в случае успеха и false иначе.
Имя - пакетный адрес сокита.

<ul><a name=141></a><h2>binmode  файл</h2></ul>
	Открыть файл для двоичного (binary) режима доступа.
В обычном режиме при вводе символы CR LF транслируются в LF,
а при выводе LF транслируется в CR LF.

<ul><a name=142></a><h2>bless  ссылка, класс</h2></ul>
bless ссылка

	Данная функция определяет что объект указанный ссылкой
принадлежит классу. Если класс не указан то он относится к текущему
классу. Обычно это последний оператор в конструкторе объекта.
Необходимо обязательно указывать имя класса если определяемый
объект может наследоваться классом-потомком.

<ul><a name=143></a><h2>caller  выражение</h2></ul>
caller
	Возвращает контекст вызова текущей подпрограммы.
В скалярном контексте true если это подпрограмма или процедура
вызванная операторами eval() или require() и false - иначе.
В списковом это список ($package, $filename, $line)
где
	$package - имя пакета
	$filename - имя файла пакета
	$line - номер строки откуда был сделан вызов.

Если указано выражение то возвращается список:

	($package, $filename, $line, $subroutine, $hasargs, $wantargs)
Выражение определяет "глубину" вложенности просмотра стека вызовов.

	$subroutine - имя подпрограммы
	$hasargs - имеющиеся аргументы
	$wantargs - необходимые аргументы
Применение данной функции в DB пакете возвращает более детальную
информацию. К списку аргументов добавляется список @DB::args.

<ul><a name=144></a><h2>chdir выражение</h2></ul>

	Перейти в директорию указанную выражением. Если
выражение отсутсвует то перейти в "домашнию" директорию.
Возвращает true в случае успеха и false - неудачи.

<ul><a name=145></a><h2>chmod список</h2></ul>

	Изменить права доступа к файлам указанным в списке.
Первый элемент в списке - числовое ,обычно восьмеричное значение прав.
Возвращает количество файлов которым были изменены права.

Пример:		chmod 0666 'f1', 'f2', 'f3';

<ul><a name=146></a><h2>chomp переменная</h2></ul>
chomp список
chomp
	Удаляет в конце строки символ указанный переменной $/.
Обычно это 'LF'. Возвращает количество удаленных символов.
Если переменная не указана то используется переменная $_.
Если указан список то обрабатывается каждая строка списка и
возвращается общее количество удаленных символов.

<ul><a name=147></a><h2>chop переменная</h2></ul>
chop список
chop
	Полностью аналогично функции chomp но всегда удаляет
последний символ строки.

<ul><a name=148></a><h2>chown список</h2></ul>

	Изменить "владельца" и "группу" файлов списка.
Первый элемент - номер нового владельца, второй номер новой группы
а далее список файлов.
В большинстве Юникс-систем вы не сможете сменить владельца если вы
не суперпользователь, но можете изменить группу если это одна из
ваших "вторичных" групп.

<ul><a name=149></a><h2>chr чмсло</h2></ul>
	Возвращает символ с указанным кодом кодировки.

<ul><a name=150></a><h2>chroot директория</h2></ul>

	Сделать "корневой" указанную директорию.
"Корневая" - значит внутри программы на нее можно ссылаться как '/'.

<ul><a name=151></a><h2>close файл</h2></ul>
	Закрыть открытый файл или поток. Можно не использовать
если один и тот же файл открывается повтортно т.к. он будет
автоматически закрываться новым вызовом open().

<ul><a name=152></a><h2>closedir директория</h2></ul>

	Закрыть директорию открытую функцией opendir().

<ul><a name=153></a><h2>connect	сокит, имя</h2></ul>

	Связаться с удаленным сокитом. Данная функция подобна
системному вызову connect(). Возвращает true в случае успеха
и false при ошибке.

<ul><a name=154></a><h2>cos выражение</h2></ul>
	Косинус выражения в радианах.

<ul><a name=155></a><h2>crypt	текст, salt</h2></ul>

	Шифрация текта. Аналогично системному crypt().

<ul><a name=156></a><h2>dbmclose хеш</h2></ul>

	Закрывает связь между хеш и базой данных.

<ul><a name=157></a><h2>dbmopen хеш, база, режим</h2></ul>

	Ассоциировать указанный хеш и базу в определенном режиме.
Дело в том что в Пел реализован очень удобный механизм работы
с базами данных типа dbm, ndbm, sbdm, gdbm и Berkeley DB. Для этого нужно
связать (открыть) базу под именем хеша. Вся работа с записями
базы выполняется так будто это обычный хеш (ассоциативный массив).
Более подробно смотрите описание функции AnyDBM().

<ul><a name=158></a><h2>define выражение</h2></ul>
	Возвращает true если значение определено (существует)
и false если нет. Многие операции завершаются не определенным
значением, например чтение после конца файла, использование
не определенных переменных, системные ошибки и т.д.
Данная функция позволяет различать нулевое и не определенные
значения, определенность или не определенность функций или
ссылок. При использовании определенности ключа в хеше
она возвращает определен данный ключ или нет но не существует
он или нет.

<ul><a name=159></a><h2>delete выражение</h2></ul>
	Удалить значение из хеша. Возвращает удаляемое значение
или не определенность если ни чего не удаляется.
Удаление из массива окружения $ENV{} - изменяет окружение.
Удаление из хеша связанного с базой данных - удаляет запись в
базе данных.

<ul><a name=160></a><h2>die список</h2></ul>
	Если программа не была запущена из eval() данная
функция выводит список в поток STDERR и завершает работу
программы с кодом из переменной $!. Если $! содержит 0
то с кодом ($? >> 8). Если и это 0 то с кодом 255.
При вызове из eval() сообщение об ошибке заносится в переменную $@
и eval() завершается с неопределенным значением. Это позволяет
отробатывать ошибочные ситуации не завершая головной модуль.
Если строка из списка не завершается символом '\n' то дополнительно
печатается номер строки скрипта откуда вызвана функция и номер
входной строки исли таковой имеется.

<ul><a name=161></a><h2>do BLOCK</h2></ul>
	Это не совсем функция. Здесь возвращается значение
последнего оператора блока. Когда используется циклический модификатор
BLOCK исполняется перед проверкой условия цикла в отличии от обычных
циклов.


<ul><a name=162></a><h2>do подпрограмма</h2></ul>
	Устаревший метод вызова подпрограмм.

<ul><a name=163></a><h2>do выражение</h2></ul>
	Значение выражения воспринимается как имя файла Пел скрипта.
Изначально это применялось для включения подпрограмм библиотеки.
Сейчас правильней использовать вызовы use() и require() которые
обеспечивают контроль  ошибок и завершения.

<ul><a name=164></a><h2>dump метка</h2></ul>
	Выполнние "дампа" текущей памяти. Применялось для
возможности исрользовать программу undump что бы включить текущий
исполняемый код в программу после инициализации всех переменных.
Выполнение этой новой программы будет начинаться оператором
goto метка. Если метка опущена то запуск сначала.
Внимание! Файлы открытые до момента дампа не будут открытыми
в момент исполнения  новой программой.

<ul><a name=165></a><h2>each хеш</h2></ul>
	Возвращает 2-элементный массив. Первый элемент - ключ
второй - значение следующего элемента хеша. Позволяет
"просматривать" все значения хеша в определенном порядке.
Сброс переменной цикла происходит только после прохлждения всего
массива.

<ul><a name=166></a><h2>eof файл</h2></ul>
eof()
eof
	Возвращает 1 если выполняется чтение после конца или
чтение из не открытого файла. Аргументом должно быть выражение
возвращающее существующий указатель файла. Данную функцию нельзя
использовать для чтения файлов открытых как терминалы.
Если аргумент не указан то используется последний читаемый файл.
Использование в форме eof() целесообразно применять в циклах
while(&lt;>) для определения конца только последнего файла из
списка. Применяйте eof(ARGV) или eof для определения конца
каждого файла из списка.

<ul><a name=167></a><h2>eval выражение</h2></ul>
eval блок
	Выражение сканируется и выполняется как обычная Пел программа.
Это делается в контексте текущей программы поэтому можно использовать
уже определенные переменные и подпрограммы.
Ворзвращается результат последнего оператора в блоке или значение
оператора return. Если обнаружится синтаксическая ошибка или выполнится
оператор die возвращается не определенное значение а переменная $@
содержит сообщение об ошибке. Если ошибки не было то $@ содержит
нулевую строку. При отсутсвии аргумента берется значение переменной $_.

<ul><a name=168></a><h2>exec список</h2></ul>
	Выполняется системная команда из списка и выполнение
программы завершается. Если вам необходимо вернуться то лучше
применяйте функцию system(). Если в списке количество аргументов
больше 1 или список это массив с количеством элементов больше 1
то выполняется системный вызов execvp() с аргументами из списка.
Если один скалярный аргумент то он сканируется на обработку
метасимволов и если они присутсвуют то полученные аргуметы
передаются интерпретатору /bin/sh -c для дальнейшей обработки.
Если метасимволов нет то аргумент расщепляется на слова и передается
системному вызову execvp() что более эффективно.
Внимание! exec() и system(0) не сбрасывают буфер ввода/вывода
поэтому необходимо установить переменную $| для предотвращения
потери выходной информации.

<ul><a name=169></a><h2>exists выражение</h2></ul>
	Возвращает true если существует указанный ключ хеша
даже если не определено его значение.

<ul><a name=170></a><h2>exit выражение</h2></ul>
	Выполнение программы завершается с кодом выражения.

<ul><a name=171></a><h2>exp выражение</h2></ul>
	Возвращает e (основание натурального логарифма) в степени
выражения.

<ul><a name=172></a><h2>fcntl файл, функция, скаляр</h2></ul>
	Выполняет системный вызов fcntl(). Для использования
обязательно выполнить use Fcntl;

<ul><a name=173></a><h2>fileno файл</h2></ul>
	Возвращает описатель файла для данного указателя файла.

<ul><a name=174></a><h2>flock файл, операция</h2></ul>
	Системный вызов flock()

<ul><a name=175></a><h2>fork</h2></ul>
	Системный вызов fork(). Возвращает pid потомка для родителя
и 0 для потомка в случае успеха иначе - неопределенное значение.

<ul><a name=176></a><h2>format</h2></ul>
	Декларативная функция Пел. Определяет формат вывода для
оператора write. Подробно смотрите главу Форматы.

<ul><a name=177></a><h2>formline формат, список</h2></ul>
	Внутренняя функция используемая в format. Форматирует
вывод параметров из списка. Результат помещается в переменную $^A
Функция write просто выводит значение этой переменной, но ее так же
можно читать а затем обнулять. Обычно format выполняе один вызов
formline для одной строки формы, но formline не разделяет строки
формата. Это значит что символы '~' и '~~' рассматривают весь
формат как одну строку поэтому необходимо использовать многострочные
формыд для описания одной записи формата.

<ul><a name=178></a><h2>getc файл</h2></ul>
getc
	Читает и возвращает символ из указанного файла.
Если файл не указан то читается STDIN. После конца файла возвращает
пустую строку.

<ul><a name=179></a><h2>getlogin</h2></ul>
	Возвращает текущий login из файла /etc/utmp
Не применяйте для идентификации пользователя он не так сильно
"закрыт" как getpwuid().

<ul><a name=180></a><h2>getpeername сокит</h2></ul>
	Возвращает упакованный адрес удаленного сокита.

<ul><a name=181></a><h2>getpgrp PID</h2></ul>
	Возвращает группу процесса с указанным PID. Если
аргумент отсутсвует возвращает группу текущего процесса.


<ul><a name=182></a><h2>getppid</h2></ul>
	Возвращает PID родительского процесса.

<ul><a name=183></a><h2>getpriority WHICH, WHO</h2></ul>
	Возвращает текущий приоритет процесса, группы процессов
или пользователя.

<ul><a name=184></a><h2> * Группа системных вызовов * </h2></ul>

getpwnam NAME

getgrnam NAME

gethostbyname NAME

getnamebyname NAME

getprotobyname NAME

getpwuid UID

getgrid GID

getservbyname NAME, PROTO

gethostbyaddr ADDR, ADDRTYPE

getnetbyaddr ADDR, ADDRTYPE

getprotobynumber NUMBER

getservbyport PORT, PROTO

getpwent

gethostent

getnetent

getprotoent

getservent

setpwent

setgrent

sethostent STAYOPEN

setnetent STAYOPEN

setprotoent STAYOPEN

setservent STAYOPEN

endpwent

endgrent

endhostent

endnetent

endprotoent

endservent

	Все эти функции анологичны одноименным системным вызовам.
В списковом контексте возвращают следующие списки:

($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) = getpw*

($name, $passwd, $gid, $members) = getgr*

($name, $aliases, $addrtype, $length, @addrs) = gethost*

($name, $aliases, $addrtype, $net) = getnet*

($name, $aliases, $proto) = getproto*

($name, $aliases, $port, $proto) = getserv*

В скалярном контексте возвращается имя или что-то другое в зависимости
от типа функции.
Элемент $members в вызове getgr содержит разделенные пробелом имена
членов группы.
@addrs содержит IP адреса компьютеров в сети Интернет в упакованном виде.
Для распаковки применяйте: ($a, $b, $c, $d) = unpack('C4',$addr[0]);


<ul><a name=185></a><h2>getsockname сокит</h2></ul>
	Возвращает упакованный адресс сокита локальной машины.

<ul><a name=186></a><h2>getsockopt сокит, уровень, опция</h2></ul>
	Возвращает опцию сокита.

<ul><a name=187></a><h2>glob выражение</h2></ul>
	Возвращает список файлов удовлетворяющих выражению с '*'
как в команде ls.

<ul><a name=188></a><h2>gmtime выражение</h2></ul>
	Переводит местное время полученное функцией time() во время
по Гринвичу.
Обычно используется в виде:

($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=gmtime(time);

<ul><a name=189></a><h2>goto метка</h2></ul>
goto выражение
goto &amp;подпрограмма
	Бузусловный переход на метку. Нельзя делать переход на
метку в структуру которая должна быть инициирована например подпрограмму
или цикл foreach и т.д.
Вторая форма применяется для динамического определения перехода.

Например:
	goto ('метка1', 'метка2', 'метка3')[$i];

Здесь при $i = 0 будет переход на 'метка1', $i = 1 на 'метка2' и т.д.

Третья форма (goto &amp;подпрограмма) довольно "хитрый" метод подмены
имени вызываемой подпрограммы именем текущей. Это используется
в методе автозагрузки когда нужно запустить другую процедуру
но под именем текущей как-будто та была вызвана раньше.

<ul><a name=190></a><h2>grep блок, список</h2></ul>

grep выражение, список
	Выполнят блок или выражение для каждого элемента списка.
Переменная $_ содержит текущий элемент.
Возвращает список элементов с которыми выражение дало результат true.
В скалярном контексте возвращает количество результатов true.

<ul><a name=191></a><h2>hex выражение</h2></ul>
	Воспринимает выражение как строку шестнадцетиричных цифр
и возвращает десятичное значение.

<ul><a name=192></a><h2>import</h2></ul>
	В Пел нет встроенной функции import, но есть метод
с помощью которого модули могут экспортировать область имен
другим модулям. Подробно смотрите функцию use().

<ul><a name=193></a><h2>index строка, подстрока, позиция</h2></ul>
index строка, подстрока
	Возвращает позицию первого вхождения подстроки в строке
начиная с указанной позиции. Если позиция отсутсвует то сравнение
начинается с начала строки. Отсчет позиции ведется с 0 если только
не изменено значение встроеной переменной $[. Если подстрока не
найдена то результат меньше первой позиции на 1. Обычно это -1.

int выражение
        Возвращает целую часть выражения.

<ul><a name=194></a><h2>ioctl FILEHANDLE, FUNCTION, SCALAR</h2></ul>
	Выполняет системный вызов ioctl(). В начале программы
необходимо указать: require "ioctl.ph";

<ul><a name=195></a><h2>join выражение, список</h2></ul>
	Соединяет строки списка или массива в одну строку
с кодом разделителя равному выражению.

<ul><a name=196></a><h2>keys хеш</h2></ul>
	Возвращает массив всех ключей хеша. В скалярном
контексте - количество ключей. Порядок следования ключей
аналогичен порядку в each фунуции.

<ul><a name=197></a><h2>kill список</h2></ul>
	Послать сигнал (первый элемент) указанным в списке
процессам. Возвращает количество процессов которые сигнал приняли.

<ul><a name=198></a><h2>last метка</h2></ul>
last
	Функция аналогичная break в С. Прерывает цикл и переходит
на указанную метку. Если метки нет на ближайший внешний цикл.
Блок continue не выполняется.

<ul><a name=199></a><h2>lc выражение</h2></ul>
	Преобразовать строку в буквы нижнего регистра.

<ul><a name=200></a><h2>lcfirst выражение</h2></ul>
	Заменить первую букву строки на малую.

<ul><a name=201></a><h2>length выражение</h2></ul>
	Возвращает длину строки выражения.

<ul><a name=202></a><h2>link OLDFILE, NEWFILE</h2></ul>
	Создать файл NEWFILE связанный с файлом OLDFILE.

<ul><a name=203></a><h2>listen SOCKET, QUEUESIZE</h2></ul>
	Выполнить системный listen().

<ul><a name=204></a><h2>local список</h2></ul>
	Объявляет перечисленные переменные как локальные в текущем
блоке или подпрограмме. Если указано два и более имени их
необходимо заключить в круглые скобки. Предпочтительней использовать
функцию my().

<ul><a name=205></a><h2>localtime выражение</h2></ul>
	Преобразовать 9-элементный массив возвращаемый фугкцией
time относительно местного времени. Употребляется как:

($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);

<ul><a name=206></a><h2>log выражение</h2></ul>
	Возвращает натуральный логарифм выражения.

<ul><a name=207></a><h2>lstat файл</h2></ul>
lstat выражение
	То же что и системный вызов stat() но касательно ссылки
на файл а не самого файла.

<ul><a name=208></a><h2>m//</h2></ul>
	Оператор соавпадения. Смотри главу "Операторы"

<ul><a name=209></a><h2>map блок, список</h2></ul>
map выражение, список
	Выполняет блок или выражение для каждого элемента списка.
Возвращает список результатов.

<ul><a name=210></a><h2>mkdir директория, права</h2></ul>
	Создать директорию с указанными правами доступа. Возвращает
1 при успехе и 0 при неудаче.

<ul><a name=211></a><h2>msgctl ID, CMD, ARG</h2></ul>
	Системный вызов msgctl() System V

<ul><a name=212></a><h2>msgget KEY, FLAGS</h2></ul>
	Системный вызов msgget() System V

<ul><a name=213></a><h2>msgsnd ID, MSG, FLAGS</h2></ul>
	Системный вызов msgsnd() System V

<ul><a name=214></a><h2>msgrcv ID, VAR, SIZE, TYPE, FLAGS</h2></ul>
	Системный вызов msgrcv() System V

<ul><a name=215></a><h2>my список</h2></ul>
	Объявляет локальными переменные в списке.
Если два или более имени их необходимо заключить в круглые скобки.

<ul><a name=216></a><h2>next метка</h2></ul>
next
	Аналогичен continue в С. Переход к следующей итерации в цикле.
Если в цикле присутсвует блок continue он так же выполняется.
Если метка отсутсвует - переход на ближайший внутренний цикл.

<ul><a name=217></a><h2>no Module список.</h2></ul>
	Исключить использование указанных модулей.

<ul><a name=218></a><h2>oct выражение</h2></ul>
	Возвращает десятичное число представленное восьмеричными цифрами.

<ul><a name=219></a><h2>open файл,выражение</h2></ul>
open файл
	Открыть файл с указанным именем. Аргумент "файл" - это
фактически указатель на блок описания файла. Если имя (выражение)
файла отсутсвует то имя считается таким же как и указатель файла.
Если перед именем стоит символ '&lt;' то файл открывается только
на чтение (значение по умолчанию). Если '>' - на запись.
Если '>>' - на добавление записей. '+>' или '+&lt;' - файл открыт
на чтение и запись одновременно.
Если имя файла начинается с символа '|' то имя считается системной
командой на вход которой выводятся данные (поток).
Имя '-' - стандартный вход (STDIN), '>-' - стандартный вывод (STDOUT).
Функция возвращает true при успехе и false - неудаче.

	Если имя (выражение) начинается с символов ">&amp;" то остаток
имени считается именем указателя файла который окрывается повторно.
Символ '&amp;' может стоять после '&lt;', '>>', '+>', '+>>' и '+&lt;'.
Режим повторного открытия должен соответсвовать первому.
Выражение вида "&lt;&amp;=N" где N -число, эквивалентно системному вызову
fdopen().
Если имя "|-" или "-|" то происходит "расщепление" (fork) процесса
на потомка и родителя. При этом возвращается номер процесса потомка
(PID) внутри родительского процесса и 0 - внутри потомка. При этом
запись/чтение в файл родительским процессом воспринимается как
чтение/запись потомком. Для потомка это стандартный ввод/вывод.
Родительский процесс ждет завершения потомка после закрытия потока
и получает код завершения в переменной $?.
Имя файла не должно содержать пробелов как в начале так и в конце.


<ul><a name=220></a><h2>opendir указатель, выражение</h2></ul>
	Открыть директорию с именем выражения для обработки
функциями readdir(), telldir(), seekdir(), rewinddir() и closedir().
Возвращает true при успехе.

<ul><a name=221></a><h2>ord выражение</h2></ul>
	Возвращает ascii код первого символа выражения.

<ul><a name=222></a><h2>pack шаблон, список</h2></ul>
	Упаковывает список в двоичную структуру по шаблону.
Шаблон - это строка символов описывающая порядок и тип упакованных
значений.

	A	- текстовая строка, добавляется пробелами.

	a	- текстовая строка, добавляется 0 символом.

	b	- битовая строка (возрастающая нумерация бит)

	B	- битовая строка (убывающая нумерация бит)

	h	- шестнадцатеричная строка ( младший байт - первый)

	H	- шестнадцатеричная строка (старший байт первый)

	c	- символ со знаком

	C	- символ без знака.

	s	- короткое целое (один байт) со знаком.

	S	- короткое целое без знака.

	i	- целое (два байта) со знаком.

	I	- целое без знака.

	l	- длинное целое (4 байта) со знаком.

	L	- длинное целое без знака.

	n	- короткое в "сетевом" формате.

	N	- длинное в "сетевом" формате.

	v	- короткое в "VAX" формате.

	V	- длинное в "VAX" формате.

	f	- single float.

	F	- double float.

	p	- указатель на строку ограниченную 0.

	P	- указатель на структуру с фиксированной длиной.

	u	- упаковка uuencode.

	x	- нуль-байт

	X	- резервный байт.

	@	- заполнить нулями позицию.

За каждой буквой может стоять число означающее количество повторов.
Для всех типов за исключением 'a', 'A', 'b', 'B', 'h' и 'H',
упаковывается максимально возможное количество значений из списка.
Символ '*' после типа означает использовать оставшиеся параметры.
Тип 'a' и 'A' использует только одно значение из списка и добавляет
остаток поля либо нуль-символами либо пробелами (при распаковке
по типу 'A' пробелы и нули отбрасываются, а по 'a' - нет).
Типы 'b' и 'B' упаковывают строку в указанное число бит.
Так же как и 'h' и 'H' в число ниблов (байт).
'P' - упаковывает указатель на структуру с указанной длиной.
Числа с плавающей запятой (floats и double) записываются в
стандартном для каждой машины формате и могут быть разными
для разных типов машин. Заметьте, что Пел всегда использует
двойную точность (double) поэтому упаковка и распаковка по
типу 'f' приведет к потере точности.
Шаблоны для распаковки и упаковки совершенно одинаковы.

Примеры:

	print(pack("ccc",65,66,67)); # Результат ABC

	print(pack("A4A3","ab","cdefg")); # "ab  cde"

	print(pack("a4a3","ab","cdefg")); # "ab\0\0cde"

<ul><a name=223></a><h2>pipe READHANDLE, WRITEHANDLE</h2></ul>
	Аналогичен системному pipe().

<ul><a name=224></a><h2>pop массив</h2></ul>
	Удаляет и возвращает последний элемент массива.
Длина массива уменьшается на 1. Результат не определен если массив
пустой. Если имя массива отсутсвует то извлекает из @ARGV
для головной программы и @_ для полпрограммы.

<ul><a name=225></a><h2>pos скаляр</h2></ul>
	Возвращает смещение от последнего m//g поиска.

<ul><a name=226></a><h2>print файл список</h2></ul>
print список
print
	Выводит строку или список строк в файл. Возвращает true
при успехе. Аргумент файл может быть скалярной переменной содержащей
имя указателя файла если он отсутсвует то осуществляется вывод
в стандартный выходной поток STDOUT (если не было вызова select()).
Если список отсутсвует то выводится значение переменной $_.
Для вывода по умолчанию в другой файл необходимо использовать
функцию select().
Так как print работает в списковом контексте, то все элементы списка
так же вычисляются в списковом контексте т.е. функции будут возвращать
списковые значения. Аргументы можно заключать в круглые скобки.
Если указатель файла - элемент массива то элемент нужно заключить
в фигурные скобки для вычисления блока.

<ul><a name=227></a><h2>printf файл список</h2></ul>
printf список
	Аналогичен вызову "print файл sprintf(список)".
Первый элемент списка должен быть форматом printf() как и в С.

<ul><a name=228></a><h2>push массив, список</h2></ul>
	Добавить элементы массива значениями из списка.
Длина массива увеличивается на количество элементов списка.

<ul><a name=229></a><h2>q/строка/</h2></ul>
qq/строка/
qx/строка/
qw/строка/
	Обычные операторы строк. Смотри главу Операторы.

<ul><a name=230></a><h2>quotemeta выражение</h2></ul>
	Вычисляет выражение в котором метасимволы рассматриваются
как обычные символы.

<ul><a name=231></a><h2>rand выражение</h2></ul>
rand
	Возвращает случайное число в диаппазоне между 0 и выражением.
Если выражение отсутсвует - между 0 и 1. Данная псевдослучайная
последовательность сбрасывается функцией srand().

<ul><a name=232></a><h2>read файл, скаляр, длина, смещение</h2></ul>
read файл, скаляр, длина
	Прочитать указанное число байт из файла в скалярную переменную.
Возвращает количество прочитаных байт или неопределенность при
ошибке. Длина скаляра станет равной количеству считанных байт. Смещение
указывают если данные нужно поместить не с самого начала строки.

<ul><a name=233></a><h2>readdir директория</h2></ul>
	Возвращает имя следующего файла в директории открытой командой
opendir(). В скалярном контексте возвращает все оставшиеся имена
файлов. Если файлов больше нет то возвращает неопределенность в
скалярном контексте и пустую строку в списковом.

<ul><a name=234></a><h2>readlink выражение</h2></ul>
	Возвращает значение символической ссылки. При ошибке
возвращает неопределенное значение.

<ul><a name=235></a><h2>recv SOCKIT, SCALAR, LEN, FLAGS</h2></ul>
	Получить сообщение из сокита. Аналогичен системному recvfrom().

<ul><a name=236></a><h2>redo метка</h2></ul>
redo
	Перейти к началу блока минуя вычисление условия и блока
continue. Если метка отсутсвует то переход к ближайшему внешнему
блоку.

<ul><a name=237></a><h2>ref выражение</h2></ul>
	Возвращает true если выражение это ссылка иначе - false.
Возвращаемое значение зависит от типа ссылки. Существуют
следующие типы ссылок:

	REF, SCALAR, ARRAY, HASH, CODE, GLOB

Если аргумент - ссылка на класс то возвращается имя класса.
Функция ref() аналогична функции typeof().

<ul><a name=238></a><h2>rename старое_имя, новое_имя_файла</h2></ul>
	Переименовать файл. Возвращает 1 в случае успеха иначе 0.

<ul><a name=239></a><h2>require выражение</h2></ul>
require
	Если выражение - число, требует что бы текущая версия
Пел была не ниже указанной. Если строка - считывает библиотечный файл
с указанным именем если он еще не прочитан.
Последний оператор библиотечного файла должен возвращать true.
Обычно это строка вида 1;
Если расширение имени файла отсутсвует то по умолчанию принимается ".pm"
В данной функции можно указывать путь расположения файла, а если
библиотека расположена в стандартной системной области Пел то вместо
require предпочтительней использовать use().

<ul><a name=240></a><h2>reset выражение</h2></ul>
reset
	Обычно используется в блоках continue циклов для
очистки переменных и поиска для повторного применения.
Выражение воспринимается как список символов. Для указания
диаппазона можно применять символ минус '-'.
Все переменные и массива начинающиеся с этих символов
обнуляются. Если выражение отсутсвует то обнуляестя поиск
?шаблон? для повторного поиска. Сбрасываются только
переменные текущего модуля.

Пример:
	reset 'a';	# очистить все переменные начинающиеся
			# буквой 'a'
	reset 'a-z'	# все переменные с малых букв.

Выражение вида: 'A-Z' употреблять не рекомендуестя т.к.
обнуляются важные массивы @ARGV и @ENV.

<ul><a name=241></a><h2>return список</h2></ul>
	Выход из подпрограммы с указанным кодом. Если данная
функция отсутсвует то выход из подпрограммы осуществляется с
кодом последнего выполненного оператора.

<ul><a name=242></a><h2>reverse список</h2></ul>
	В списковом контексте возвращает список с элементами
в обратном порядке указанному списку. В скалярном контексте
возвращает строку спереставленными символами первого элемента
списка.

<ul><a name=243></a><h2>rewindir директрия</h2></ul>
	Устанавливает указатель файлов открытой директории
в начало для последующего чтения функцией readdir().

<ul><a name=244></a><h2>rindex строка, подстрока, позиция</h2></ul>
rindex строка, подстрока
	Подобна функции index , но возвращает позицию последнего
вхождения подстроки в строку. Если указана позиция, то просмотр
выполняется до нее.

<ul><a name=245></a><h2>rmdir директория</h2></ul>
	Удалить указанную директорию если в ней нет никаких файлов.
Возвращает 1 при успехе и 0 при не удаче. При этом переменная $!
содержит код (errno).

<ul><a name=246></a><h2>s///	Оператор подстановки. Смотри главу "Операторы".</h2></ul>

<ul><a name=247></a><h2>scalar выражение</h2></ul>
	Вычисляет выражение в скалярном контексте и возвращает
результат. В Пел нет специальной функции для принудительного
вычисления в списковом контексте т.к. для достаточно заключить
его в круглые скобки.

<ul><a name=248></a><h2>seek файл, позиция, отсчет</h2></ul>
	Установить указатель на произвольную позицию в файле.
Если отсчет равен 0 - позиционировать от начала файла, если  1 - от
текущего положения, 2 - от конца файла. Возвращает 1 при успехе
и 0 - неудаче.

<ul><a name=249></a><h2>seekdir директория, позиция</h2></ul>
	Установить указатель файла в открытой директории для
последующего чтения функцией readdir(). Текущая позиция
может быть получена функцией telldir().

<ul><a name=250></a><h2>select файл</h2></ul>
select
	Возвращает текущий указатель файла- по умолчанию
или делает текущим указанный. Таким образом если в функциях
print или write не указан файл вывода то это осуществляется
в файл указанный select. Переменные связанные с выводом так же
действуют на вывод в этот файл.

select RBITS, WBITS, EBITS, TIMEOUT
	Выполняет системный select()

<ul><a name=251></a><h2>semctl ID, SEMNUM, CMD, ARG</h2></ul>
	Системный вызов semctl() для SYSTEM V.

<ul><a name=252></a><h2>semget KEY, NSEMS, FLAGS</h2></ul>
	Системный вызов semget() для SYSTEM V.

<ul><a name=253></a><h2>semop KEY, OPSTRING</h2></ul>
	Системный вызов semop() для SYSTEM V.

<ul><a name=254></a><h2>send SOCKET, MSG, FLAGS, TO</h2></ul>
send SOCKET, MSG, FLAGS
	Послать сообщение через сокит. Аналогично системному send().

<ul><a name=255></a><h2>setpgrp PID, PGRP</h2></ul>
	Установить номер группы PGRP процессу с номером PID
	0 = для текущего процесса.

<ul><a name=256></a><h2>setpriority WHICH, WHO, PRIORITY</h2></ul>
	Установить приоритет PRIORITY процессу пользователя WHO
и группе WHICH.

<ul><a name=257></a><h2>setsockopt SOCKET, LEVEL, OPTNAME, OPTVAL</h2></ul>
	Установить параметры сокита. Воззвращает неопределенность
при ошибке.

<ul><a name=258></a><h2>shift массив</h2></ul>
shift
	Удаляет первый элемент массива и возвращает его значение.
Если массив пустой то результат неопределенность. Если аргумент
опущен - обрабатывается массив @ARGV в головной программе
или @_ в подпрограмме.

<ul><a name=259></a><h2>shmctl ID, CMD, ARG</h2></ul>
	Системный вызов shmctl() System V

<ul><a name=260></a><h2>shmget KEY, SIZE, FLAGS</h2></ul>
	Системный вызов shmget() System V

shmread ID, VAR, POS, SIZE
shmread ID, STRING, POS, SIZE
	Пишет или читает сегмент общедоступной памяти в System V.

<ul><a name=261></a><h2>shutdown SOCKET, HOW</h2></ul>
	Прекращает работу сокита методом HOW.

<ul><a name=262></a><h2>sin выражение</h2></ul>
	Возвращает в радианах синус выражения.

<ul><a name=263></a><h2>sleep выражение</h2></ul>
sleep
	Приостанавливает работу процесса на указанное число секунд
или зацикливается если аргумент отсутсвует. Работа продолжается если
получен сигнал SIGALARM. Возвращает время фактической паузы.

<ul><a name=264></a><h2>socket SOCKET, DOMAIN, TYPE, PROTOCOL</h2></ul>
	Открывает сокит и привязывает его к указателю SOCKET.

<ul><a name=265></a><h2>socketpair SOCKET1, SOCKET2, DOMAIN, TYPE, PROTOCOL</h2></ul>
	Создает "безымянную" пару сокитов в указаном DOMAIN.
Возвращает true при успехе и false - неудаче.

<ul><a name=266></a><h2>sort подпрограмма список</h2></ul>
sort блок список
sort список
          Сортирует  элементы  списка  и  возвращает полученный
список.  Не существующие элементы списка отбрасываются. Если не
указано  имя  подпрограммы  или блок то сортирует в стандартном
строковом порядке.
     Указанная  подпрограмма возвращает значения больше, меньше
или равное  нулю  в  зависимости  от  двух  соседних  элементов
списка.  Имя подпрограммы может быть указано переменной. Она не
должна быть рекурсивной  и  два  сравниваемых  элемента  списка
передаются  как  глобальные переменные $main::a и $main::b. Это
ссылки  поэтому  их  изменение  приводит  к   изменению   самих
элементов списка.

<ul><a name=267></a><h2>splice массив, смещение, длина, список</h2></ul>
splice массив, смещение, длина
splice массив, смещение
	Удаляет элементы массива начиная со смещения и указанной длины.
Заменяет их указанным списком. Возвращает удаленный список.
Если длина не указана удаляет все элементы списка начиная со смещения.

<ul><a name=268></a><h2>split /шаблон/, выражение, предел</h2></ul>
split /шаблон/, выражение
split /шаблон/
split
	Разделяет строку,указанную выражением, на массив элементов и возвращает его.
В скалярном контексте возвращает количество полученных элементов массива,
а сам массив помещает в @_ (в списковом контексте поместить результат
в @_ можно если применить ?шаблон?)
Если выражение отсутсвует то обрабатывается содержимое переменной $_.
Если шаблон отсутсвует то разделителем является пробел.
Все что подходит по шаблону считается разделителем. Если указан предел
то это максимальное число разделений. Отрицательное значение предела
воспринимается как неограниченно большой предел.
Если пустая строка походит под шаблон разделителя то исходное значение
разделяется по символьно.
Предел удобно использовать для частичного разделения строки.

Пример:
	($a, $b, $остаток) = split(/ /, "Один Два Три Четыре",3);

здесь $a = 'Один', $b = 'Два' и $остаток = 'Три Четыре'

Если шаблон содержит круглые скобки то символы-разделители указанные
в них вставляются в результирующий список как обычные элементы,
причем вставляется символ который совпал с разделителем.

Пример:

        @a = split(/([,.])/, "Один,Два.Три");

здесь @a = ("Один", "," ,"Два", ".", "Три")

<ul><a name=269></a><h2>sprintf формат, список</h2></ul>
	Форматирует список по указанному формату аналогично
функции sprintf() языка С.

<ul><a name=270></a><h2>sqrt выражение</h2></ul>
	Возвращает корень квадратный выражения.

<ul><a name=271></a><h2>srand выражение</h2></ul>
	Задает начальное значение для генератора случайных чисел
оператора rand. Если аргумент отсутсвует то используется текущее
машинное время.

<ul><a name=272></a><h2>stat файл</h2></ul>
stat выражение
	Возвращает 13 элементный массив параметров указанного файла
или пустой список при ошибке. Применяется обычно следующим образом:

($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
$blksize,$blocks) = stat($filename);

где
	$dev	- имя устройства
	$ino	- номер i-узла
	$mode	- права доступа
	$nlink	- количество связей
	$uid	- идентификатор владельца
	$gid	- идентификатор группы
	$rdev	- тип устройства
	$size	- размер файла в байтах
	$atime	- дата последнего обращения
	$mtime	- дата последней модификации
	$ctime	- дата последнего изменения статуса
	$blksize - размер блока на диске
	$blocks	- количество блоков в файле.

Если указан аргумент '_' то возвращается результата предыдущего
вызова stat().

<ul><a name=273></a><h2>study скаляр</h2></ul>
study
	Влючение метода частотного сравнения. Целесообразность
применения зависит от количества поисков и количества констант в
строке в которой ведется поиск.
Функция работает следующим образом:
Для указанного скаляра (если аргумент отсутсвует берется значение
переменной $_) строится список указателей на каждый символ строки.
Затем когда начинается поиск первыми просматриваются символы которые
наиболее редко встречаются в английском языке.
Выигрыш по времени очевиден когда выполняется многократный поиск
в одной и той же строке и время затраченной на индексацию окупается.

<ul><a name=274></a><h2>substr выражение, смещение, длина</h2></ul>
substr выражение, смещение
	Возвращает подстроку выражения начиная со смещения и заданной
длины. Если смещение отрицательное то отсчет ведется от конца строки.
Если длина не указана то берется все до конца строки.

<ul><a name=275></a><h2>symlink старый_файл, новый_файл</h2></ul>
	Создает новый файл символически связанный со старым т.е.
создает ссылку на файл. Возвращает 1 при успехе и 0 - неудаче.

<ul><a name=276></a><h2>syscall список</h2></ul>
	Выполняет системную функцию. Первый элемент списка - это
имя функции а остальные элементы - ее аргументы.
Если функция не выполнима то возвращается фатальная ошибка.
Аргументы интерпретируются следующим образом.
Если аргумент число, то оно считаестя целым. Если не число то аргумент
считается указателем на строку. Вам необходимо обеспечить достаточную
длину аргумента для подстановки значения указателя. В Пел передается
максимум 14 параметров. Обычно этого достаточно.

<ul><a name=277></a><h2>sysread файл, скаляр, длина, смещение</h2></ul>
sysread файл, скаляр, длина
	Прочитать из файла указанное число байт в скаляр с помощью
системного вызова read(). Смещение обозначает позицию в скаляре
после которой будут вставлены прочитанные байты.

<ul><a name=278></a><h2>system список</h2></ul>
	Делает то же самое что и "exec список" с той лишь разницей
что вызов fork() делается первым и родительский процесс ждет
завершения потомка. Возвращает значение аналогичное функции wait().
Для получения действительного кода завершения необходимо разделить
на 256.

<ul><a name=279></a><h2>syswrite файл, скаляр, длина, смещение</h2></ul>
syswrite файл, скаляр, длина
	Записать в файл укзанное число байт скаляра с помощью
системного вызова write(). Смещение указывает позицию в скаляре
откуда начинается запись.

<ul><a name=280></a><h2>tell файл</h2></ul>
tell
	Возвращает текущую позицию указателя в открытом файле.
Если файл не указан то последнего читаемого файла.

<ul><a name=281></a><h2>telldir директория</h2></ul>
	Возвращает текущую позицию указателя в открытой директории.
Обычно это параметр для позиционирования указателя директории
функцией seekdir().

<ul><a name=282></a><h2>tie переменная, класс, список</h2></ul>
	Присваивает переменную классу. Список - это аргументы
new метода класса (TIESCALAR, TIEARRAY или TIEHASH).
Возвращает указатель на созданный новый объект класса который
удобен для вызова других методов класса.
Внимание! Такие функции как keys() и values() могут вернуть
в качесте значения огромное количество данных.

Для создания объекта ассоциативного типа необходимо определение
следующих методов:

	TIEHASH classname, LIST
	DESTROY this
	FETCH this, key
	STORE this, key, value
	DELETE this, key
	EXISTS this, key
	FIRSTKEY this
	NEXTKEY this, lastkey

Обычного массива:

	TIEHASH classname, LIST
	DESTROY this
	FETCH this, key
	STORE this, key, value
	[others TBD]

Скалярного типа:

	TIEHASH classname, LIST
	DESTROY this
	FETCH this, key
	STORE this, key, value

<ul><a name=283></a><h2>time</h2></ul>
	Возвращает количиство секунд начиная с 1 января 1970 г
00:00:00 UTC. Годы не разделяются на високосные.

<ul><a name=284></a><h2>times</h2></ul>
	Возвращает 4-х элементный массив значений:

	($user, $system, $cuser, $csystem) = times;

где:

	$user	-  пользовательское время процесса в секундах.

	$system	- системное время текущего процесса.

	$cuser	- время процесса-потомка текущего прцесса.

	$csystem - его системное время.

tr///
	Опрератор транслятор. Подробно смотри главу "Операторы".

truncate файл, длина
truncate выражение, длина
	Усекает длину указанного файла.

<ul><a name=285></a><h2>uc выращение</h2></ul>
	Возвращает строку выражения в которой малые буквы заменены
на заглавные.

<ul><a name=286></a><h2>ucfirst выражение</h2></ul>
	Возвращает строку выражения в которой первая буква заменена
на заглавную.

<ul><a name=287></a><h2>umask выражение</h2></ul>
umask
	Устанавливает маску umask и возвращает старое значение.
Без аргумента возвращает текущее значение.

<ul><a name=288></a><h2>undef выражение</h2></ul>
undef
	Делает неопределенным значение выражения. Применяется
только для скалярных переменных, целых массивов или подпрограмм.
Всегда возвращает неопределенное значение.

<ul><a name=289></a><h2>unlink список</h2></ul>
	Удаляет файлы указанные в списке. Возвращает количество
удаленных файлов. Только супервизор может удалять директории
с файлами если Пел запущен с ключом -U.

<ul><a name=290></a><h2>unpack шаблон, выражение</h2></ul>
	Функция обратная pack(). Распаковывает строку выражения
по указанному шаблону в массив значений. В скалярном контексте
возвращает значение только первого элемента. Шаблоны такие же
как и в pack().
Символ '%' в шаблоне означает что вы хотите получить вместо
значения его контрольную сумму. По умолчанию 16 битовую.

<ul><a name=291></a><h2>untie переменная</h2></ul>
	Исключает переменную из класса указанного tie().

<ul><a name=292></a><h2>unshift массив, список</h2></ul>
	Противоположное shift. Помещает элементы списка
в начало массива.

<ul><a name=293></a><h2>use модуль список</h2></ul>
use модуль
	Указывает библиотечный модуль из которого можно
вызывать подпрограммы. Список перечисляет имена подпрограмм которые
добавляются к текущей область имен. Если не указан то все имена.
Действие аналогично блоку:

	BEGIN { require модуль; import модуль список; }

Сам модуль должен распологаться в системной области Пел файлов.

<ul><a name=294></a><h2>utime список</h2></ul>
	Изменяет дату обращения и модификации файлов из списка.
Первые два элемента списка должны указывать новое значение даты
обращения и модификации.
Возвращает количество измененных файлов.

<ul><a name=295></a><h2>values хеш</h2></ul>
	Возвращает обычный массив со всеми значениями хеша.
В скалярном контексте возвращает количество значений хеша.

<ul><a name=296></a><h2>vec выражение, смещение, бит</h2></ul>
	Возвращает значени строки как вектор без знаковых целых.

<ul><a name=297></a><h2>wait</h2></ul>
	Ожидать окончание порожденного процесса. Возвращает
PID для родительского процесса или -1 если нет процесса потомка.
Код завершения записывается в переменную $?.

<ul><a name=298></a><h2>waitpid PID, FLAGS</h2></ul>
	Ожидать окончания процесса потомка с указанным PID.
Возвращает либо PID этого процесса либо -1 если нет такого процесса.
Код завершения записывается в перменную $?.

<ul><a name=299></a><h2>wantarray</h2></ul>
	Возвращает true если подпрограмма вызывается в списковом
контексте и false - в скалярном.

<ul><a name=300></a><h2>warn список</h2></ul>
	Выодит в стандартный поток ошибок STDERR сообщение
аналогично die(), но не прекращает работу программы.

<ul><a name=301></a><h2>write файл</h2></ul>
write выражение
write
	Выводит в файл форматированные данные по оператору
format. По умолчанию имя формата совпадает с именем указателя файла.
Имя файла-по умолчанию можно изменить функцией select(), а имя
формата при этом надо присвоить переменной $~.
Заголовок листа пишется автоматически. Если на листе не хватает
места для вывода то выводится "перевод формата" и специальная
форма заголовка листа затем сами записи.
По умолчанию имя формата заголовка листа состоит из имени указателя
файла и добавленной строки "_TOP". Динамически это млжно делать
присваивая формат переменной $^. Количество оставшихся строк листа
содержится в переменной $- и если присвоить ей 0 то произойдет
смена листа. Подробно описание форматов смотри в главе "Форматы".

<ul><a name=302></a><h2>y///</h2></ul>
	Оператор транслятор. Смотри главу "Операторы".

<ul><a name=303></a><h2> * Подпрограммы * </h2></ul>

Для применения подпрограммы ее необходимо определить либо в текщем модуле
(файле) либо во внешнем модуле (файле).
Подпрограммы определяются и декларируются следующим образом:

	sub имя;	# Только декларация. Определение ниже.

	sub имя (прототипы);  То же но с декларацией параметров.

	sub имя блок;	# Декларация и определение.

	sub имя (прототипы) блок; # То же, но с парамметрами.

Для определения динамичской анонимной подпрограммы можно указать:

	$переменная = sub блок;

Для импортирования подпрограмм из других модулей используйте:

	use модуль qw(подпрограмма1 подпрограмма2 );

Вызов подпрограммы:

	имя(список параметров);	# символ '&amp;' можно не указывать.

	имя список;	# Если подпрогрмма уже декларирована.

	&amp;имя;		# Параметры в @_

Все параметры передаются подпрограмме как массив @_.
Соответсвенно $_[0] - первый параметр, $_[1] - второй и т.д.
Массив @_ - локальный, но он содержит адреса параметров поэтому
можно изменять значение параметров.
Возвращаемое значение подпрограммы - результат последнего оператора.
Это может быть как скаляр так и массив. Можно принудительно возвращать
результат используя функцию return().

Подпрограмму можно вызвать используя префикс '&amp;' перед именем
подпрограммы. Если подпрограмма предварительно продекларирована то
префикс и скобки можно опустить.

<ul><a name=304></a><h2>Private переменные.</h2></ul>

Для применения переменных доступных только внутри блока или подпрограммы
необходимо определить их с помощью функции my(список).

Если переменная одна то скобки можно опустить.

my() декларирует private переменные в пределах текущей подпрограммы,
блока, функции eval() или do/require/use файлов. Private переменные
аналогичны auto переменным в С.

Пример:

	# Программа вычисления факториала.

	print fact(3);  # вычислить факториал 3*2*1

	sub fact	# Определяем подпрограмму.
	{ my $m;                # private переменная но не local !
	$m = $_[0];
	return 1 if $m &lt;= 1;
	return($m * fact($m -1));
	}

Можно указывать начальные значения private переменных как:

	my(список) = выражение;

Так для вышеприведенного примера лучше было написать:

	my($m) = $_[0];


Переменные типа local.

В общем лучше использовать private переменные так-как это надежней и
быстрее. private переменные обеспечивают лексическую область применения
(видимости) а local - динамическую. Обычно это переменные форматов
значение которых должно быть видимо из вызываемых подпрограмм.
Применение функции local() не целесообразно в циклах так как
она вызывается каждый раз и таким образом заметно замедляет время
выполнения цикла.


<ul><a name=305></a><h2>Прототипы (prototypes).</h2></ul>

Для краткого описаня типа параметров передаваемых подпрограмме
можно применять прототипы. В Пел существуют следующие прототипы:

	Декларация		Пример вызова

	sub mylink($$)		mylink $old, $new
	sub myvec($$$)		myvec $var, $offset, 1
	sub myindex($$;$)	myindex &amp;getstring, "substr"
	sub myreverse(@)	myreverse $a, $b, $c
	sub myjoin($@)		myjoin ":",$a,$b,$c
	sub mypop(\@)		mypop @array
	sub mysplice(\@$$@)	mysplice @array, @array, 0, @pushme
	sub mykeys(\%)		mykeys %{$hashref}
	sub myopen(*;$)		myopen HANDLE, $name
	sub mypipe(**)		mypipe READHANDLE, WRITEHANDLE
	sub mygrep(&amp;@)		mygrep { /foo/ } $a, $b, $c
	sub myrand($)		myrand 42
	sub mytime()		mytime

Здесь:
	\'символ'	- параметр с типом 'символ'

	'@' или '%'	- все оставшиеся параметры как список

	'$'		- скаляр

	'&amp;'		- безимянная подпрограмма

	'*'		- ссылка на таблицу имен

	';'		- разграничитель обязательных и не обязательных параметтров.


<ul><a name=306></a><h2>Ссылка как параметр.</h2></ul>

Иногда нужно в качестве параметра передать подпрограмме не значение
элемента массива а ссылку на него, что бы подпрограмма могла изменить
значение элемента. Для этого в Пел к имени переменной добавляется
символ '*' Подбное выражение называют 'type glob' так как в Юниксе
символом '*' обозначают "все возможные значения". Поэтому '*' для
массива означает "все элементы массива".
Для скаляров употряблять '*' не имеет смысла т.к. они и так передаются
ссылкой и вы можете изменять значение параметра изменяя например
переменную $_[0].


<ul><a name=307></a><h2>Переопределение встроенных функций.</h2></ul>

Большинство встроенных функций Пел можно переопределить своими
собственными. Обычно это делают для удобства совместимости Пел для
разных платформ систем.

Для этого нужно перечислить имена этих функций в виде:

	use subs 'функция1', 'функция2' ....;

и далее в модуле определить сами функции.


<ul><a name=308></a><h2>Автозагрузка.</h2></ul>

Если вы попытаетесь вызвать не существующую функцию то Пел выдаст
немедленно сообщение об ошибке. Но если вы определите подпрограмму
с именем 'AUTOLOAD' то она будет вызвана с теми же параметрами
а переменная $AUTOLOAD будет содержать имя не существующей
подпрограммы. Данный механизм очень удобен для средств отладки.

<ul><a name=309></a><h2> * Модули (packages) * </h2></ul>

     В  Пел  реализован  механизм  модулей.  Модуль  это группа
подпрограмм и переменных обычно включенных в один файл.  Внутри
одного  модуля  можно  определить  другой модуль. Начало модуля
определяется директивой:

	packages имя_модуля;

     Конец  модуля  это  конец блока или файла. Головной модуль
имеет по  умолчанию  имя  main.  На  имя  внутри  модуля  можно
ссылаться добавляя '::' после имени модуля.
 Например:

	$main::var1	- переменная в головном модуле.

	::var1		- то же самое. Имя main можно опускать.

	$модуль1::var1	- переменная в модуле 'модуль1'

	$модуль1::модуль2::var1 - Модуль2 содержится в модуле 1.

Только идентификаторы начинающиеся с буквы или символа '_' хранятся
в пространтсве имен текущего модуля. Остальные хранятся в пространстве
головного модуля main.
Кроме этого имена STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC и SIG
так же хранятся в головном модуле.

<ul><a name=310></a><h2>Таблицы имен.</h2></ul>

Все имена модуля хранятся в ассоциативном массиве (хеше) с именем
модуля к которому добавлены символы "::". Таким образом имена
головного модуля хранятся в %main:: , модуля 'mod1' в %mod1::
и т.д. Выражение вида *имя указывает значение элемента хеша 'имя'
это удобно для определения констант.

Например:
	*pi = \3.14159;

Здесь переменная $pi - это константа пи которую уже нельзя изменить.

<ul><a name=311></a><h2>Конструкторы и деструкторы.</h2></ul>

Конструктор - это подпрограмма которая выполняется в момент создания
объекта, а деструктор - удаления объекта. Для модуля это подпрограммы
с именами BEGIN и END. При определении этих подпрограмм слово
sub можно опускать.

Конструктор BEGIN выполняется сразу как только возможно т.е. как только
он определен даже не завершая дальнейший разбор программы. Можно указать
несколько блоков BEGIN. Они будут выполняться один за другим в порядке
определения.

Деструктор END выполняется последним как только возможно т.е. при
завершении работы интерпрератора. Можно указать несолько блоков END
при этом они будут выполняться в обратном определению порядке.


<ul><a name=312></a><h2>Классы.</h2></ul>

В Пел нет специального синтаксиса для классов. Но функционально
полноценными классами могут быть модули. При этом подпрограммы модуля
становятся методами, а с помощью массива @ISA можно реализовать
механизм наследования в классах. Более подробно классы описаны отдельно.

<ul><a name=313></a><h2>Создание библиотеки.</h2></ul>

Если вы хотоите создать модуль отдельным файлом и использовать
как библиотеку подпрограмм, при этом вызывать подпрограммы библиотеки
не указывая имени модуля, вам необходимо оформить модуль следующим
образом:

	package имя_модуля;	# Такое же как и имя этого файла без расширения '.pm'
	require Exporter;	# Обязательная строка для экспорта имен
	@ISA = qw(Exporter);	# -//-
	@EXPORT = qw(func1 func2) # Перечисляем имена функций. Внимание ! нет запятой!
	@EXPORT_OK = qw( $переменная @массив ); # Указать публичные переменные, массивы и т.д. если необходимо
	{  # Начало блока модуля
	.....
	sub func1
	........
	sub func2
	........
	1;
	}

Данный файл с расширением ".pm" должен храниться в одной из библиотечных
директорий Пел. Они перечислены в массиве @INC одно из них обычно
"/usr/local/lib/perl/".

В головной программе вы указываете:

	use имя_модуля;

и вам становятся доступны имена подпрограмм данного модуля.


<ul><a name=314></a><h2>Стандартные Пел библиотеки.</h2></ul>

Стандартный набор библиотек обычно поставляется с дистрибутивом Пел
они разделяются на pragma библиотеки (работают как директивы компилятору)
и стандартные библиотеки.

Pragma библиототеки.

Данные библиотеки используют как:

	use имя;

когда хотят включить действие и

	no имя;

когда выключить.

<ul><a name=315></a><h2>В стандартный набор входят следующие pragma:</h2></ul>

diagnostics
	Включить режим расширенной диагностики.

integer
	Использовать целочисленную арифметику.

less
	Режим минимальной загрузки компилятора.


overload
	Режим переопределения операторов.

sigtrap
	Режим слежения за прерываниями.

strict
	Режим ограниченного использования "опасных" операторов.

subs
	Режим обязательного декларирования подпрограмм.


Стандартные библиотеки.

AnyDBM_File
	Возможность работы с разными типами баз данных.

AutoLoader
	Загрузка в память функций только во время вызова.

AutoSplit
	Разделить модуль для автозагрузки.

Benchmark
	Анализ скорости исполнения программы.

Carp
	Предупреждения об ошибках.

Config
	Доступ к конфигурации Пел.

Cwd
	Получить имя текущей рабочей директории.

DB_File
	Работа с базой данных формата Berkley DB.

Devel::SelfStubber
	Режим отладки автозагрузки.

DynaLoader
	Динамическая загрузка библиотек C.

English
	Использовать длинные имена встроенных переменных.

Env
	Импортировать имена переменных окружения

Exporter
	Обеспечивает экспорт/импорт для модулей.

ExtUtils::LibList
	Определяет используемые библиотеки.

ExtUtils::MakeMaker
	Создает файл проекта Makefile

ExtUtils::Manifest
	Программы для создания и проверки файла MANIFEST

ExtUtils::Mkbootstrap
	Применеие файла начальной загрузки для DynaLoader.

Fcntl
	Определения как и в С Fcntl.h

File::Basename
	Синтаксический разбор спецификации файла.

File::CheckTree
	Быстрый проход по директориям диска.

File::Find
	Быстрый поиск файлов по директориям.

FileHandle
	Обеспечивает объектный метод доступа к указателям файлов.

File::Path
	Создание/удаление директорий.

Getopt::Long
	Расширенная обработка опций.

Getopt::Std
	Стандартная обработка опций.

I18N::Collate
	Сравнение символов локалбной кодировки.

IPC::Open2
	Межпроцессорный обмен по чтению и записи.

IPC::Open3
	Межпроцессорный обмен по чтению, записи, и обрабоки ошибок.

Net::Ping
	Тест доступа к хосту.

POSIX
	Стандартный интерфейс по IEEE Std 1003.1

SelfLoader
	Загрузка функций только по вызову.

Socket
	Определение структур и констант как и в С socket.h

Test::Harness
	Стандартный тест с статистикой.

Text::Abbrev
	Создание таблицы сокращений по списку.

Подробное описание каждой библиотеки записано в самом файле.


<ul><a name=316></a><h2>CPAN</h2></ul>

     Програмисты   всего   мира   работающие   с   Пел  создали
общедоступную  библиотеку  модулей  CPAN.  Она  доступна  через
Интернет и содержит огромное количество различных по назначению
модулей.
     К   ним   относятся  документаторы,  системные  интерфесы,
интерфейсы работы с базами данных, работа в  сети,  с  файлами,
Интернет-броузеры,  системы  поиска,  огромное  количество  CGI
скриптов для  Web  серверов  и  многое  многое  другое.  Список
некоторых CPAN серверов вы можете найти в приложении.

<ul><a name=317></a><h2> * Форматы * </h2></ul>

     В  Пел  реализован  удобный метод создания форматированных
отчетов.  С помощью оператора format вы  описываете  заголовки,
размеры  полей,  указываете положение данных на листе в удобной
текстовой форме. Затем выполняете команду  write(файл)  которая
выводит отформатированные данные в указанный файл.

Оператор формат имеет следующий синтаксис:

	format имя =
	FORMLIST
	.

Обратите внимание на то что описание формата идет после строки format и заканчивается
символом '.' в начале строки.

Здесь 'имя' - это имя формата, такое же как и имя указателя выходного файла.
Если 'имя' отсутсвует то значение по умолчанию - STDOUT.

FORMLIST - это строки формата. Они бывают трех типов:

	1. Комментарий. Строка начинается символом '#'.

	2. Описатель полей данных (picture).

	3. Строка аргументов используемых описателем.

Описатель - это строка которая выводится в виде "как есть" за исключением
специально обозначенных форматов полей данных. Каждое поле начинается
либо символом '@' либо '^'.
В описательной строке указывается только положение и вид
выводимых данных, но не имена полей и переменных.
Для этого предназначена следующая строка аргументов которая следует всегда
после описателя и содержит имена переменных или целые выражения
в порядке указанном описателем.

Размер и вид поля в описателе обозначается следующими символами:

	">>>>"	- выровнить значение по правому краю.

	"&lt;&lt;&lt;&lt;"	- -//- по левому.

	"||||"	- -//- по центру.

	"####.###"	- формат числа с точкой.

	"@*"	- многострочная строка. Данные выводятся в колонку.

Размер поля равен количеству указанных символов.

Символ '^' в начале поля имеет специальное значение.

Так:
	"^####"	- пусто если переменная не определена.

для строчного скаляра:

	"^&lt;&lt;&lt;&lt;&lt;" - Выводится сколько возможно символов, а значение
переменной меняется на остаток вывод которого можно продолжить на
следующих строках которые могут иметь свои поля.

Пример:

#!/usr/local/bin/perl
#
#	Программа печати пригласительного билета
#
$кому = "Чапаеву Василию Ивановичу";

$от_кого = "Компания МММ";

$адрес = "Москва, ул. Петровка, д 38";

$текст = "Уважаемый Василий Иванович! Компания МММ имеет честь пригласить
Вас и Ваших близких на презентацию наших новых хромовых сапог, сделанных
на уровне мировых стандартов качества и дизайна.";

format STDOUT =

	П Р И Г Л А С И Т Е Л Ь Н Ы Й      Б И Л Е Т
----------------------------------------------------------------------
Кому: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  | ^|||||||||||||||||||||||||||||||
      $кому,				$текст
                                   | ^|||||||||||||||||||||||||||||||
      					$текст
От кого: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  | ^|||||||||||||||||||||||||||||||
      $от_кого,				$текст
                                   | ^|||||||||||||||||||||||||||||||
      					$текст
Адрес:@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  | ^|||||||||||||||||||||||||||||||
      $адрес,				$текст
                                   | ^|||||||||||||||||||||||||||||||
      					$текст
                                   | ^|||||||||||||||||||||||||||||||
      					$текст
                                   | ^|||||||||||||||||||||||||||||||
      					$текст
----------------------------------------------------------------------
Отпечатано в типографии ИТУ 38
.

write();	# Вывод данных.
exit 0;		# Конец программы


Результат:


	П Р И Г Л А С И Т Е Л Ь Н Ы Й      Б И Л Е Т
----------------------------------------------------------------------
Кому: Чапаеву Василию Ивановичу    |   Уважаемый Василий Иванович!
                                   |     Компания МММ имеет честь
От кого: Компания МММ              |  пригласить Вас и Ваших близких
                                   |    на презентацию наших новых
Адрес:Москва, ул. Петровка, д 38   |   хромовых сапог, сделанных на
                                   |    уровне мировых стандартов
                                   |       качества и дизайна.
                                   |
----------------------------------------------------------------------
Отпечатано в типографии ИТУ 38

Специальные переменные:

	$~	- построчный формат содержимого.

	$^	- формат заголовка листа.

	$%	- номер листа.

	$=	- строк в листе.

Если вы хотите использовать одни и те же форматы для разных файлов
то самый простой путь:

	use FileHandle;	# Указать в начале программы

	format_name файл имя_формата; # Формат содержимого листа.

	format_top_name файл имя_формата; # Формат заголовка листа.

	write(файл);	# вывод данных.


Здесь 'файл' имеется ввиду указатель файла полученный командой open();

Если вам нужно в теле листа выводить разного рода форматы (например
заголовки групп или отбивку листа) то применяйте format_name.

<ul><a name=318></a><h2> * Отладка Пел программ * </h2></ul>

В Пел реализован превосходный механизм отладки программ.
Вам достаточно запустить программу с ключом '-d' и вы начнете работать
с интерактивным отладчиком. Вам становятся доступны все переменные и
массивы, вы можете вводить выражения и операторы, трассировать,
исследовать работу программы в по-шаговом режиме и многое другое.
Ниже перечисленны команды отладчика которые вы можете вводить
на его подсказку.

Команды отладчика.

	h	- Получить справку по командам.

	T	- Просмотреть стек программы

	s	- Выполнить одну команду и остановиться.

	n	- Выполнить подпрограмму и остановиться.

	r	- Выполнить текущую подпрограмму и остановиться.

	c	- Продолжить выполнение до сдедующей точки остановки.

	c номер	- Продолжить выполнение до строки с данным номером.

	&lt;CR>	- Повторить последнию команду n или s.

	l min+incr	- Вывести incr+1 строк программы начиная со строки min.

	l min-max	- Вывести строки начиная с min до max.

	l номер	- Вывести строку с указанным номером.

	l	- Вывести следующий экран строк.

	-	- Вывести предыдущий экран строк.

	w строк	- Вывести экран строк. Текущая в середине.

	l подпрограмма	- Вывести строки указанной подпрограммы.

	/шаблон/	- Найти строку в тексте программы.

	?шаблон?	- Обратный поиск строки в тексте программы.

	L	- Вывести строки с точками останова и активами.

	S	- Вывести имена всех подпрограмм.

	t	- Включить или выключить трассировку.

	b строка [ условие] - Установить точку остановки.

	b подпрограмма [ условие ] - Установить точку остановки в начале
указанной подпрограммы и если указано при данном условии.

	d	- Убрать точку остановки.

	D	- Убрать все точки остановки.

	a строка команда - Установить актив (команду которая выполнится вместе
с указанной строкой. "команда" - обычныая команда Пел.

	A	- Стереть все активы.

	&lt; команда	- Выполнять команду перед каждой остановкой.

	> команда	- Выполнить команду после остановки отладчика.

	V модуль [имена] - Вывести значение всех или указанных имен
в модуле. Внимание! Символ '$' не вводится.

	X [имена]	- То же что и V , но только для текущего модуля.

	! номер	- Выполнить одну строку программы.

	! -номер	- Выполнить одну команду с номером предшествующим
			текущей строке.

	H - n	- Вывести n последних выполненных команд.

	q или ^D	- Выход из программы.

	команда		- Выполнить команду Пел.

	p выражение	- Вывести значение выражения.

Конструктор BEGIN не отслеживается отладчиком, но можно в теле конструктора
указать:
	$DB::single =1;

и отладчик остановится. Данная команда не вызовет ошибку при работе
без отладчика.

<ul><a name=319></a><h2> * Список литературы * </h2></ul>

     При написании книги автор в основном пользовался описанием
Пел "Perl Programmers Reference Guide".

Наиболее известная зарубежная литература:

	Programming Perl (the Camel Book)

	Learning Perl (Llama Book)

<ul><a name=320></a><h2> * Интернет - ссылки * </h2></ul>

<ul><a name=321></a><h2>Очень полезные USENET конференции:</h2></ul>

	comp.lang.perl.announce - Различные объявления и сообщения.

	comp.lang.perl.misc - Место для вопросов и обсуждений.

	comp.lang.perl.modules - Модули Пел.

	comp.lang.perl.tk - Пел и Tcl/tk.


<ul><a name=322></a><h2>WWW сервера:</h2></ul>

	<a href=http:///www.perl.org>http://www.perl.org</a>
                                - Специальный Пел-сервер

	<a href=http://www.ora.com>http://www.ora.com</a>
                                - Книги по Юникс издательства O`Reily

	<a href=ftp://ftp.perl.com>ftp://ftp.perl.com</a>
                                - Специализированный FTP сервер

	<a href=http://franz.ww.tu-berlin.de/modulelist/>http://franz.ww.tu-berlin.de/modulelist</a>

<pre><hr noshade><small>Популярность: <b>4</b>, Last-modified: Sun, 02 Jul 2000 22:34:02 GMT
</small>

</body></html>
